---
title: "[혼자 공부하는 컴퓨터구조+운영체제]03장 명령어"
excerpt: "고급 언어와 저급 언어, 컴파일 언어와 인터프리터 언어, 명령어의 구조, 주소 지정 방식에 대하여"
categories:
  - book_notes
tags:
  - 혼자 공부하는 컴퓨터구조+운영체제
---

# 03-1 소스 코드와 명령어

## 고급 언어와 저급 언어

- 고급(high-level) 언어: 사람이 이해하기 쉬운 언어
- 저급(low-level) 언어: 컴퓨터가 이해하고 실행할 수 있는 언어
  - 기계어
    - 0과 1로 이루어진 명령어로 구성
  - 어셈블리어
    - 기계어를 읽기 쉬운 형태로 변환한 언어

## 컴파일 언어와 인터프리터 언어

- 고급 언어 → 저급 언어 변환 방식
  - 컴파일
    - 컴파일 언어(고급 언어) → 저급 언어
  - 인터프리트
    - 인터프리터 언어(고급 언어) → 저급 언어

### 컴파일 언어

- 대표적으로 C
- 컴파일: 소스 코드 전체를 저급 언어로 변환하는 과정
  - 컴파일러가 소스 코드 전체를 확인하며, 오류 발견 시 컴파일 실패
- 목적 코드(object code): 컴파일러를 통해 저급 언어로 변환된 코드

### 인터프리터 언어

- 대표적으로 Python
- 인터프리트: 소스 코드를 한 줄씩 저급 언어로 변환하여 실행
  - 중간에 오류를 발견해도 그전까지는 올바르게 실행
- 한 줄씩 저급 언어로 해석하며 실행하기 때문에 컴파일 언어보다 느림

### 목적 파일과 실행 파일

- 목적 파일: 목적 코드로 이루어진 파일
- 실행 파일: 실행 코드로 이루어진 파일
  - 대표적으로 `.exe` 확장자를 가진 파일
- 링킹: [컴파일러가 만들어낸 하나 이상의 목적 파일을 가져와 이를 단일 실행 프로그램으로 병합](<https://ko.wikipedia.org/wiki/%EB%A7%81%EC%BB%A4_(%EC%BB%B4%ED%93%A8%ED%8C%85)>)하는 과정
  - 목적 파일에 링킹 작업을 거쳐야 실행 파일 생성

# 03-2 명령어의 구조

## 연산 코드와 오퍼랜드

- 명령어 = 연산 코드 + 오퍼랜드
- 연산 코드(operation code, 연산자): 명령어가 수행할 연산
- 오퍼랜드(operand, 피연산자): 연산에 사용할 데이터 또는 데이터가 저장된 위치

### 오퍼랜드

- 오퍼랜드 필드를 주소 필드라고도 한다.
  - 일반적으로 데이터보다 데이터가 저장된 위치를 담기 때문
- 0-주소 명령어: 오퍼랜드가 없는 명령어
  - 1-주소 명령어, 2-주소 명령어, 3-주소 명령어: 오퍼랜드가 각각 1개, 2개, 3개인 명령어

### 연산 코드

기본적인 연산 유형은 다음과 같다.

- 데이터 전송
  - MOVE
  - STORE
  - LOAD(FETCH)
  - PUSH
  - POP
- 산술/논리 연산
  - ADD/SUBTRACT/MULTIPLY/DIVIDE
  - INCREMENT/DECREMENT
  - AND/OR/NOT
  - COMPARE
- 제어 흐름 변경
  - JUMP
  - CONDITIONAL JUMP
  - HALT
  - CALL → 함수 호출
  - RETURN
- 입출력 제어
  - READ(INPUT)
  - WRITE(OUTPUT)
  - START IO
  - TEST IO

## 주소 지정 방식

- 오퍼랜드 필드에 주소를 담는 이유
  - n 비트의 오퍼랜드 필드에 데이터를 담는 경우 표현할 수 있는 데이터의 가짓수 ⇒ 2ⁿ
  - n 비트의 오퍼랜드 필드에 데이터 주소를 담는 경우, 표현할 수 있는 데이터의 가짓수 2ⁿ개로 한정되어 있지 않고, 많이 늘어난다.
- 주소 지정 방식(addressing mode): 연산에 사용할 데이터 위치를 찾는 방법 ⇒ 유효 주소를 찾는 방법
  - 유효 주소(effective address): 연산 코드에 사용할 데이터가 저장된 위치

### 즉시 주소 지정 방식

- immediate addressing mode
- 연산에 사용할 데이터를 오퍼랜드 필드에 명시하는 방식
- 표현할 수 있는 데이터 크기가 작음
- 데이터를 찾는 과정이 없기 때문에 가장 빠름

### 직접 주소 지정 방식

- direct addressing mode
- 유효 주소(메모리 주소)를 직접적으로 오퍼랜드 필드에 명시하는 방식
- 즉시 주소 지정 방식보다 많은 데이터 표현 가능
- 오퍼랜드 필드 길이가 표현할 수 있는 유효 주소의 크기를 제한함

### 간접 주소 지정 방식

- indirect addressing mode
- 유효 주소의 주소를 오퍼랜드 필드에 명시하는 방식
- 직접 주소 지정 방식보다 많은 데이터 표현 가능
- 즉시 주소 지정 방식, 직접 주소 지정 방식보다 느림

### 레지스터 주소 지정 방식

- 유효주소(연산에 사용할 **데이터를 저장한 레지스터**)를 오퍼랜드 필드에 명시하는 방식
- 직접 주소 지정 방식보다 빠름
  - 일반적으로 CPU 내부의 레지스터에 접근하는 것이 CPU 외부의 메모리에 접근하는 것보다 빠르기 때문
- 오퍼랜드 필드 길이가 표현할 수 있는 유효 주소의 크기를 제한함

### 레지스터 간접 주소 지정 방식

- 연산에 사용할 **데이터를 메모리에 저장**하고 그 **유효 주소를 저장한 레지스터**를 오퍼랜드 필드에 명시하는 방식
- 메모리에 한 번만 접근하기 때문에 간접 주소 지정 방식보다 더 빠름
