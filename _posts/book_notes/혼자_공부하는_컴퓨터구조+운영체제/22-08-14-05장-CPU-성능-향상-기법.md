---
title: "[혼자 공부하는 컴퓨터구조+운영체제]05장 CPU 성능 향상 기법"
excerpt: "클럭, 코어, 스레드에 대한 간단한 설명과 CPU 성능 향상을 위한 명령어 병렬 처리 기법 그리고 CISC와 RISC에 대하여"
categories:
  - book_notes
tags:
  - 혼자 공부하는 컴퓨터구조+운영체제
---

# 05-1 빠른 CPU를 위한 설계 기법

## 클럭

클럭 속도가 높으면 CPU가 빠르게 동작한다.

- 클럭 속도
  - 1초에 클럭이 몇 번 반복되는지를 헤르츠 단위로 측정한 것
  - 일정한 속도는 아니며, 일반적으로 CPU가 속도를 조절
- 오버클럭킹(overclocking)
  - CPU가 고성능이 필요할 때 순간적으로 최대 클럭 속도를 강제로 끌어올리는 것
- 클럭 속도가 높아지면 발열 문제 발생

## 코어와 멀티코어

CPU의 코어와 스레드 수를 늘리면 성능이 향상된다.

- CPU 의미의 확장
  - 이전의 CPU ⇒ 명령어를 실행하는 부품
  - 오늘날의 CPU ⇒ 명령어를 실행하는 부품을 여러 개 포함하는 부품으로 확장
    - **명령어를 실행하는 부품 ⇒ 코어**
- **멀티코어 프로세서**(멀티코어 CPU): **코어를 여러 개 포함**하는 CPU
  - 단일 코어보다 빠르다.
- 연산 속도가 증가하려면 코어마다 연산이 적절히 분배되어야 한다.
  - 코어 수가 지나치게 많다고 해서 훨씬 더 나아지지 않는다.

## 스레드와 멀티스레드

스레드는 사전적으로 실행 흐름의 단위를 의미한다.

### 하드웨어적 스레드

- 하나의 코어가 동시에 처리하는 **명령어 단위**
  - CPU가 여러 스레드를 지원하면 하나의 코어로 여러 개의 명령어 동시 실행 가능<br>
    즉 하드웨어적 스레드를 이용하면 하나의 코어로 여러 명령어를 동시 실행 가능
- **멀티스레드 프로세서**(멀티스레드 CPU)
  - 하나의 코어로 **여러 명령어를 동시에 처리**하는 CPU
  - 여러 개의 하드웨어적 스레드를 지원하는 CPU
- 하이퍼스레딩: 인텔의 멀티스레드 기술

### 소프트웨어적 스레드

- 하나의 프로그램에서 독립적으로 실행되는 단위
- 프로그래밍 언어를 이용해 소프트웨어적 스레드 생성 가능
  - 어떠한 기능을 담당하는 코드를 각각에 스레드로 만들면 동시 실행이 가능하다.

### 멀티스레드 프로세서

- 하나의 코어로 여러 명령어를 동시에 처리하는 기술
- 하나의 명령어를 처리하기 위한 필수 레지스터 세트를 여러 개 가지고 있으면 가능
- 하드웨어 스레드는 논리 프로세서(logical processor)라고 부른다.
  - 스레드가 4개 있을 때 프로그램 입장에서는 CPU가 4개 있는 것처럼 보이기 때문

# 05-2 명령어 병렬 처리 기법

CPU는 높은 성능을 위해 쉬지 않고 작동되어야 하며 이를 위해 명령어 병렬 처리 기법을 활용한다.

- 대표적인 명령어 병렬 처리 기법
  - 명령어 파이프라이닝
  - 슈퍼스칼라
  - 비순차적 명령어 처리

## 명령어 파이프라인

- 클럭 단위로 나눈 일반적인 명령어 처리 과정
  1. 명령어 인출(Instruction Fetch)
  2. 명령어 해석(Instruction Decode)
  3. 명령어 실행(Execute Instruction)
  4. 결과 저장(Write Back)
- 명령어 파이프라이닝: **동시에 여러 개의 명령어를 겹쳐 실행**하는 기법
  - 명령어 처리 과정은 같은 단계가 아니라면 동시에 실행될 수 있기 때문
  - 명령어 파이프라인: 명령어를 넣는 곳

### 파이프라인 위험

특정 상황에서 파이프라이닝이 성능 향상에 실패하는 상황을 파이프라인 위험이라 한다.

- 데이터 위험(data hazard)
  - 명령어 간 데이터 의존성에 의해 발생
  - 예) 명령어 A와 명령어 B를 동시에 실행하려 하지만 명령어 A는 명령어 B의 결과 데이터가 있어야 하는 경우
- 제어 위험(control hazard)
  - 분기 등으로 인한 프로그램 카운터의 갑작스러운 변화에 의해 발생
  - 예) 명령어 파이프라인에서 명령어 A가 처리 중이고 뒤이어 명령어 B를 처리 중일 때, 명령어 A 실행 결과 프로그램 카운터를 변경해야 할 경우 명령어 B가 하던 작업은 쓸모가 없어진다.
  - 분기 예측(branch prediction): 프로그램이 어디로 분기할지 예측한 뒤 그 주소를 인출하는 기술
    - 제어 위험을 위해 사용하는 기술
- 구조적 위험(structural hazard)
  - 서로 다른 명령어가 동시에 CPU 부품(ALU, 레지스터 등)을 사용하려 할 때 발생
  - 자원 위험 (resource hazard)라고도 한다.

## 슈퍼스칼라(superscalar)

- CPU 내부에 **여러 개의 명령어 파이프라인**을 포함한 구조
- 슈퍼스칼라 프로세서(슈퍼스칼라 CPU): 슈퍼스칼라 구조로 명령어 처리가 가능한 CPU
  - 매 클럭 주기마다 동시에 명령어 인출, 실행 가능
- 파이프라인 개수가 늘어나면 프로그램 처리 속도가 빨라지지만, 파이프라인을 피하기 까다로워진다.

## 비순차적 명령어 처리(Out-of-order execution, OoOE)

- 순서를 바꿔서 실행해도 무방한 명령어를 먼저 실행해 파이프라인이 멈추는 것을 방지하는 기법
  - 명령어 파이프라이닝과 슈퍼스칼라는 순차적으로 명령어 처리 ⇒ 곧바로 처리되지 못하는 명령어를 만나면 명령어 파이프라인이 멈춤
- CPU가 명령어 간 데이터 의존성, 순서를 바꾸어도 되는 명령어를 판단할 수 있어야 한다.

# 05-3 CISC와 RISC

명령어 파이프라이닝과 슈퍼스칼라를 효과적으로 사용하기 위해선 명령어가 파이프라이닝 하기 쉽게 생겨야 한다.

## 명령어 집합

- 명령어 집합 (instruction set) 또는 명령어 집합 구조(Instruction Set Architecture, ISA)
  - CPU가 이해할 수 있는 명령어 모음
  - ISA가 다르면 CPU가 이해할 수 있는 명령어, 어셈블리어도 달라진다.
  - ISA에 따라 컴퓨터 구조 및 설계 방식이 달라짐
    ⇒ ISA는 CPU의 언어이면서, 하드웨어가 어떻게 소프트웨어를 이해할지에 대한 약속
- CISC와 RISC: 명령어 병렬 처리 기법 도입에 유리한 ISA

## CISC

- Complex Instruction Set Computer, 복잡한 명령어 집합을 활용하는 컴퓨터(CPU)
  - 예) 인텔 CPU의 x86, x86-64 ISA
- **가변 길이 명령어** 활용
  - 다양한 기능의 명령어 집합을 활용 → 명령어의 형태와 크기도 다양
  - **다양한 주소 지정 방식** 사용
- 장점
  - **적은 수의 명령어로 프로그램 실행** 가능
    - 따라서 컴파일한 프로그램의 크기가 작음
  - 메모리를 아껴야 하던 때 높은 인기 얻음
- 단점
  - 명령어의 크기와 실행되기까지 시간이 일정하지 않음 ⇒ 파이프라인 구현의 걸림돌
  - 명령어가 복잡해 **여러 클럭 주기가 필요함 ⇒ 파이프라인 구현의 걸림돌**
  - 자주 쓰는 명령어만 많이 사용되고 **대다수 복잡한 명령어는 사용 빈도가 낮음**

CISC는 그 단점으로 인해 CPU 성능 향상에 한계가 있다.

## RISC

- Reduced Instruction Set Computer
  - 예) 애플 CPU의 ARM ISA
- **고정 길이 명령어 활용 ⇒ 파이프라이닝에 최적화**
  - **단순하고 적은 수의, 짧고 규격화된 명령어 사용**
  - **1클럭 내외로 실행**되는 명령어 지향
- 메모리에 직접 접근하는 명령어를 제한 ⇒ 메모리 접근을 단순화하고 최소화를 추구
  - 메모리에 직접 접근하는 명령어: load, store
    - RISC를 load-store 구조라고도 한다.
  - 따라서 일반적으로 **CISC보다 주소 지정 방식의 종류가 적다.**
- 레지스터를 적극적으로 활용
  - 메모리 접근을 단순화, 최소화했기 때문
  - 일반적으로 CISC보다 레지스터를 이용한 연산과 범용 레지스터의 개수가 많다.
- **CISC보다 많은 명령어를 사용해 프로그램을 작동**
