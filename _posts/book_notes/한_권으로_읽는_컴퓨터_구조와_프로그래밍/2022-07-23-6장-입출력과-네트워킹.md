---
title: "[한 권으로 읽는 컴퓨터 구조와 프로그래밍]5장 컴퓨터 아키텍처와 운영체제"
excerpt: "컴퓨터는 외부와 어떻게 상호작용하는가"
categories:
  - book_notes
tags:
  - 한 권으로 읽는 컴퓨터 구조와 프로그래밍
---

> 컴퓨터는 외부와 어떻게 상호작용하는가

# 저수준 I/O

- CPU가 읽거나 쓸 수 있는 비트에 물건을 연결한 가장 단순한 형태의 I/O

## I/O 포트

> 포트 B에 전구와 스위치를 연결한 경우를 가정

- LED(light emitting diode): 빛을 내는 다이오드
  - 다이오드: 전기를 한 방향으로만 흐르게 제한하는 반도체 장치
- LED와 저항을 직렬로 연결
  - LED에 흐르는 전류를 제한해 LED가 타버리지 않기 위함

**포트 B**

- 세 가지 레지스터에 의해 제어
  - DDRB(Data Direction Register B): 각 판을 입력으로 쓸지 출력으로 쓸지 결정
    - 포트 B에 대한 데이터 방향 레지스터
    - 이 레지스터의 어느 비트에 1을 넣으면 그 비트 번호에 해당하는 포트 B 비트가 출력에 사용
    - 0을 넣으면 입력
  - PORTB: 출력 데이터를 저장하는 래치
    - PORTB의 어느 비트에 0이나 1을 넣으면 해당 비트가 출력 비트로 DDRB에 지정된 경우 핀의 출력 전압이 0 또는 1로 바뀜
  - PINB: 핀의 값을 읽음
    - 연관된 핀의 상태를 읽을 수 있음

## 버튼을 눌러라

**풀업(pull-up) 저항**

- 버튼이 눌리지 않은 경우 프로세서의 인터럽트 요청(interrrupt request, IRQ) 핀에 연결된 선의 전압을 공급 전압까지 올려 논리 1을 만듦
- 버튼이 눌린 경우 IRQ나 회로가 타지 않도록 전류를 제한하면서 IRQ에 논리 0 공급

**버튼 바운스**

- 버튼에 연결된 금속 조각은 접촉면이 안정되기 전까지 접점에서 여러번 튕겨나옴(bounce)
  - 이는 인터럽트를 여러번 발생시킴 ⇒ 버튼을 디바운스(debounce)해서 바운스를 없애야 함
- 디바운스
  - 인터럽트 핸들러에 **타이머를 설정**해서 바운스가 끝난 이후의 버튼 상태를 감지하게 만듦
- 디바운스를 설정하는 두 가지 방법
  - 최초 인터럽트 시 타이머를 설정
  - 인터럽트가 발생할 때마다 기존 타이머를 새 타이머로 재설정
  - 단점
    - 기계 부품이 낡으면 바운스 시간이 달라지므로 타이머 값을 정하기 어려움
    - 프로세서에 버튼의 수 만큼 인터럽트 핀이 많이 존재하지 않음
  - 대부분의 시스템에는 주기적인 인터럽트를 만드는 일종의 타이머가 존재하는데 이를 이용해 버튼 디바운싱 해결

**유한 임펄스 응답(finite impulse response, FIR)**

- FIR은 큐다.
- 어떤 버튼의 상태가 바뀌었는지 알 수 있다.

## 빛이 있으라

**7 세그먼트 디스플레이**

- 7개의 LED가 숫자 8 형태로 나열되어 있고 소수점을 표현하는 하나의 LED가 추가로 존재
- 총 8개의 LED를 처리하기 위해 각 LED에 핀을 하나 연결하고, 핀 하나에는 모든 LED 연결
  - LED를 켜거나 끌 때 한쪽 끝만 제어하면 되기 때문에 공통 연결핀을 사용한다.
  - 더 적은 핀을 사용하기에 더 싸다.

**공통 캐소드 디스플레이**

- 모든 캐소드는 한꺼번에 연결되고 각 애노드마다 별도의 핀이 배정

**시각의 잔상효과**

- 타이머 인터럽트 핸들러를 사용해 짧은 시간 간격으로 세그먼트를 껐다 켰다 하면 계속 켜진 것 처럼 보임

## 밝기 조절

**듀티 사이클**

- 디스플레이의 **듀티 사이클을 조절해 밝기를 조절**한다.
- 밝기는 디스플레이가 켜져 있는 평균 시간과 관련있다.

## 그레이의 2^n가지 그림자

- 센서를 읽어 모터, 바퀴와 같은 회전축의 위치를 알아내야 하는 경우 회전축에 스위치를 넣거나 광센서가 읽을 수 있는 검은색과 흰색 점을 사용해 위치를 알아낼 수 있다.
  - 중요한 것은 축의 위치를 2진수로 인코딩 하는 것

**그레이 코드 로터리 인코더**

- 2진 로터리 인코더는 배열 오류가 있을시 데이터를 잘못 읽게 된다. 이 문제를 해결하는 그레이 코드는 각도가 변할 때 비트가 하나씩만 달라지는 인코딩 방법이다.

## 쿼드러처

**쿼드러처 인코딩**

- 어떤 대상의 절대적 위치는 알 필요 없고, 위치가 변했는지와 어떤 방향으로 변했는지만 아는 경우 사용하는 방법

## 병렬 통신

**병렬**

- 컴포넌트 하나하나마다 별도의 선이 있기 때문에 동시에 모든 컴포넌트를 제어할 수 있다.

**스트로브**

- 데이터를 보낼 때 데이터의 변화만 관찰해서는 올바른 데이터를 보내는지 알 수 없기 때문에 유효한 데이터라고 알려주는 스트로브 신호를 추가

**병렬 인터페이스**

- I/O 핀, 커넥터 핀, 선이 많이 필요하기 때문에 비싸다.

## 직렬 통신

- 전선을 덜 써야 비용이 적게 드는 통신을 할 수 있다. 직렬 통신은 선을 최소로 사용하는 것이 목표다.
  - 전기 신호가 돌아올 경로가 필요해 전선은 최소 2개 필요
- 비트를 서로 다른 시간에 나누어 보낼 수 있다. 스트로브 또는 클록 신호가 각 비트를 한 위치씩 시프트 시키면서 밀려나가는 비트를 선을 통해 내보낼 수 있다. 수신받는 쪽은 클록이 비트를 한 자리씩 시프트 시키면서 채워넣는다.
  - 이 방법은 오류가 발생하기 쉽다.

**마크-스페이스 신호**

- 전송할 데이터를 직렬 프로토콜을 통해 신호선 하나로 전달한다.
  - 당연히 돌아올 전선도 필요
- 하이 상태를 마크, 로우 상태를 스페이스라고 한다.
  - 아무 일도 일어나지 않을 때가 하이 상태이다.
- 로우 상태는 시작 비트로써, 시작 비트 이후 데이터가 전달되고 끝에 하이 상태인 정지 비트가 붙는다.
  - 각 비트에는 같은 시간이 할당된다.
- 동기화 오류가 발생시 송신가는 문자 시간(character time)동안 수신자가 다시 동기화 하기를 기다린다.
- 시간 분할 멀티플렉싱: 시간을 나눈 슬롯을 만들고 슬롯마다 각기 다른 비트를 할당해 데이터를 한 선에 멀티플렉싱
- 보 레이트(Baud rate): 초당 비트 수

**반이중(half-duplex) 통신**

- 송신자와 수신자가 **같은 선을 공유**
  - **충돌**을 피하기 위해 메세지를 송신하고 “오버”라는 단어를 붙임
  - 충돌: 동시에 둘 이상의 송신자가 메세지를 보내는 경우
- **전이중(full-duplex) 통신**: 선이 2개여서 각기 다른 방향으로 **동시에 통신이 가능**
- UART(Universal Asynchronous Receiver-Transmitter): 이런 통신을 위한 IC
  - 비트 뱅잉(bit-banging): 소프트웨어로 구현된 UART

## 파동에 올라타라

- 장거리 통신에는 마크-스페이스 방식이 적합하지 않다.

**파장**

- 사인파: 근본적인 파장
- 진폭: 사인파의 높이
- 주파수(헤르츠, Hz, 초당 사이클): 매초 같은 방향으로 0을 지나치는 횟수
- 파장: 같은 방향으로 0을 지나는 연속된 두 지점 사이의 거리
- λ=υ/f
  - λ: 파장을 미터로 표시한 값
  - υ: 매질에서 파동의 속도
  - f: 주파수를 Hz로 표시한 값

**반송파(carrier)**

- 전달하려는 신호를 올려보낼 파동
- 이를 이용해 반송파를 마크-스페이스 파형처럼 변조(modulation)할 수 있다.
- 복조(demodulation): 수신자가 음향을 다시 마크와 스페이스로 되돌리는 작업
- 모뎀(modem): 변조와 복조를 수행하는 장치

## 범용 직렬 버스(Universal Serial Bus, USB)

- 선이 4줄뿐인 단일 커넥터
  - 두 줄의 전력선과 여러 다른 데이터 신호에 사용되는 연선(twisted pair)으로 구성
  - USB 타입 C는 선을 24개까지 사용
- 종단점(endpoint)를 담당하는 컨트롤러 존재
  - 종단점은 데이터 전송을 보장하기 위해 원하는 대역폭(데이터 전송 비율) 예약을 요청 가능
    - 충분한 대역폭이 없는 경우 컨트롤러가 요청 거부 가능
- 데이터는 패킷으로 분류
  - 패킷에는 헤더와 페이로드가 들어 있음
- 음향과 비디오를 동시성 전송(isochronous transfer)을 통해 처리 가능

# 네트워킹

- 근거리 네트워크(local area network, LAN)와 광역 네트워크(wide area network, WAN)의 경계는 모호하다.
- 회선 교환(circuit switch) 방식 네트워크
  - 과거의 전화 네트워크
  - 통화를 위해 두 사람의 전선을 연결해 회로 형성
  - 통화가 끝나면 다른 통화를 위해 새로운 회로 형성
- 패킷 교환(packet switch) 방식 네트워크
  - 현재의 전화 네트워크 시스템
  - 시간 분할 멀티플렉싱을 사용하면 같은 전선을 공유하며 패킷 전송이 가능해 더 효율적
- UUCP(UNIX-to-UNIX copy)
  - 컴퓨터가 다른 컴퓨터에게 데이터 전송, 원격 프로그램 실행 가능
  - 최초 전자우편 시스템과 유즈넷(USENET)과 같은 뉴스 시스템의 근간
  - 원하는 목적지에 도달할 때까지 한 기계에서 다른 기계로 넘기며(hop) 메시지 전달
- ARPANET
  - 패킷 스위치 방식의 WAN
  - 1990년대 인터넷으로 진화
    - 인터넷은 여러 LAN을 하나로 연결하는 WAN

## 최근의 LAN들

**이더넷(Ethernet)**

- 먼 거리 연결이 불가하므로 LAN
- 최초의 이더넷은 반이중 시스템
  - 모든 장치가 같은 선에 연결
    - 각 장치의 네트워크 인터페이스에는 **MAC(Media Access Control) 주소**가 부여
  - 데이터는 프레임(frame)이라는 이름의 패킷으로 구성
    - 송신 주소, 수신 주소, 오류 검증이 포함된 헤더와 페이로드가 함께 들어감
  - 프레임의 MAC 주소와 장치의 MAC 주소가 일치하지 않으면 장치는 데이터를 무시
  - 랜덤 백오프 후 재시도: 말하고 싶은 장치가 둘 이상 동시에 말해 충돌이 발생한 경우 임의의 시간을 기다린 뒤 다시 말하려 시도
- 요즘 이더넷은 각 장치가 라우터에 연결
  - 라우터는 어떤 장치가 어떤 선에 연결되었는지 기억하고 패킷을 정확하게 전달

## 인터넷

- 인터넷은 여러 계층으로 이루어진 프로토콜의 집합
  - 프로토콜 계층은 물리적 네트워크를 정의하는 아래쪽 계층을 변경해도 위쪽 계층에 영향을 끼치지 않도록 고안

### TCP/IP

- 전송 제어 프로토콜/인터넷 프로토콜(Transmission Control Protocol/Internet Protocol)
- 인터넷이 사용하는 두 가지 프로토콜
- IP는 패킷(데이터그램, datagram)을 한 곳에서 다른 곳으로 옮김
  - IP를 이용하면 송신자는 수신자가 메세지를 언제 받는지, 받기는 했는지도 알 수 없음
  - TCP는 IP 위에 만들어져 패킷이 제대로 전달되었는지 보장
- 패킷은 먼저 송신해도 수신이 늦어질 수 있다. 택배처럼.

### IP 주소

- 각 컴퓨터 또는 장치에는 IP 주소라는 유일한 주소 할당
- MAC 주소와 달리 하드웨어에 묶여있지 않아 변경 가능
- IP 주소 시스템은 계층적
  - 주소 중 일부를 누군가에게 할당 → 그 누군가는 다시 주소 중 일부를 다른 누군가에게 할당
- 인터넷은 대부분 IPv4에서 이루어짐
  - IPv4는 32비트 주소 사용
  - 주소는 옥텟 표기(`xxx.xxx.xxx.xxx`)를 사용해 표현됨
    - `xxx`는 32비트 주소 중 8비트(0~255)를 나타냄
  - IP 주소는 점점 부족해져 요즘은 128 비트 주소를 사용하는 IPv6를 사용하는 추세

### 도메인 이름 시스템(DNS)

- DNS는 이름을 주소로 바꿈
  - IP 주소가 바뀌어도 DNS는 알아서 이름의 IP 주소를 기억하고 있음

### 월드 와이드 웹

- SMTP(Simple Mail Transfer Protocol, 단순 우편 전달 프로토콜)
  - TCP/IP 위에 만들어짐
  - 전자우편 시스템의 작동 기반 프로토콜
- HTTP(Hyper Text Transfer Protocol), HTTPS
  - TCP/IP 위에 만들어짐
  - 웹 페이지 전송을 책임짐
  - 하이퍼텍스트: 링크가 붙은 텍스트
- HTTP 표준
  - 웹 브라우저가 웹 서버와 상호작용하는 방법을 정의
    - 웹 브라우저: 웹 페이지를 볼 때 사용하는 프로그램
    - 웹 서버: 요청한 페이지를 제공
  - URL(Uniform Resource Locator, 일관된 자원 위치 지정자)
    - 이를 통해 웹 페이지를 얻음
    - 인터넷상의 컴퓨터에 대한 도메인 이름과 이 컴퓨터 안의 어디에서 정보를 찾을지에 대한 설명 포함
- HTML(Hyper Text Markup Language)
  - 웹 페이지는 보통 HTML로서 존재

# 아날로그 처리 방법

**샘플링**

- 컴퓨터는 연속적인 대상을 저장할 방법이 없어 데이터의 샘플을 취함
  - 시간이나 공간상 일정한 간격으로 값을 읽음
- 저장한 데이터를 다시 영상이나 빛으로 보여주려면 샘플링 데이터로부터 아날로그 신호를 다시 만들어야 함

## 디지털을 아날로그로 변환

**DA 변환기(digital-to-analog converter, D/A, DAC)**

- 디지털을 아날로그로 바꾸는 변환기
- 해상도: DAC가 만드는 단계 수를 느슨히 표현하는 단어
  - 정확히는 DAC가 만들어낼 수 있는 최대 전압을 단계 수로 나눈 값
    - 만약 10비트 DAC가 최대 5V를 만들 수 있다면 해상도는 대략 0.005V(5/2^10)이다.
- DAC 입력을 일정한 비율로 변경하면 파형을 만들 수 있음
- FIFO 메모리: 더 복잡한 파형을 만들기 위해 추가 회로를 통해 데이터를 써넣기 위한 메모리에서 데이터를 읽어옴
  - 데이터를 일정한 비율로 읽어 처리하기 위해 사용
  - FIFO가 거의 비면 낮은 워터마크 트리거가 인터럽트를 발생, FIFO가 거의 꽉차면 높은 워터마크 트리거가 인터럽트 발생

## 아날로그를 디지털로 변환

**AD 변환기(analog-to-digital converter, A/D, ADC)**

- 값을 측정할 수 있도록 아날로그 신호 값을 안정적으로 잡아야 함
- 샘플 앤드 홀드 회로: 아날로그 파형의 샘플 값을 잡아내는 회로
- 비교가(comparator) 회로: 두 전압의 크기를 비교하는 회로
  - - 입력 신호가 - 입력 신호보다 크거나 같으면 1을 출력, 그렇지 않으면 0 출력
  - 여러 기준 전압(reference voltage)과 연결해 쌓으면 플래시 변환기(flash converter)

**램프 변환기(ramp converter)**

- 플래시 변환기는 비트를 효율적으로 사용 못하고 비교기를 많이 사용하기 때문에 비싸다. 이를 극복해 기준 접압을 DAC 하나에서만 얻도록 한 변환기가 램프 변환기이다.
- 샘플값을 DAC와 비교하고 두 값이 같아질 때까지 카운터가 수를 센다.
  - 카운터에 샘플을 디지털로 변환한 값이 들어있다.
- 신호에서 얻은 샘플 크기에 선형으로 비례하는 시간이 걸리기 때문에 전체적으로 오래걸린다.
  - 샘플이 최댓값이고 ADC가 n 비트라면 최대 2^n 클록이 걸려야 변환이 끝난다.

**연속 추정 변환기(successive approximation converter)**

- 하드웨어로 2진 검색을 진행해 램프 변환기보다 빠르다.
- 최악의 경우 log n 클록밖에 안걸린다.

## 디지털 오디오

- 일정 시간 간격으로 신호의 진폭이나 높이를 측정해 일차원으로 샘플링을 하면 오디오로 디지털화할 수 있다.
  - 일정 샘플링 주파수로 사각파(square wave)를 얻을 수 있고 상승 에지(rising edge)마다 A/D를 사용해 신호의 높이를 기록할 수 있다.
- 어떤 파형이든지 일련의 사인파의 가중치 합으로 표현할 수 있고 푸리에 변환을 통해 각 부분을 다시 골라낼 수 있다.
  - 푸리에 변환을 이용해 주파수에 따른 진폭을 그래프로 그릴 수 있다.

**필터**

- 로우패스: 어떤 주파수보다 낮은 주파수를 통과
- 하이패스: 어떤 주파수보다 높은 주파수를 통과
- 밴드패스: 로우패스와 하이패스를 조합해 정해진 구간의 주파수만 통과
- 노치(notch): 특정 주파수만 제외
- 롤오프(roll off): 필터 에지는 날카롭지 않다.

**압축**

- 무손실 압축(lossless compression)
  - 원래 데이터를 그대로 유지하지만 크기가 반 밖에 안줄어듦
  - FLAC(Free Lossless Audio Codec)
    - 코덱(codec, coder-decoder): 모뎀과 비슷하게 어떤 대상을 한 코딩 시스템에서 다른 코딩 시스템으로 변환하거나 되돌리는 소프트웨어 또는 하드웨어
- 손실 압축(lossy compression)
  - 음향심리학에 따라 사람이 들을 수 없는 소리를 없애 일부 세부 사항 사라지지만 높은 압축률을 제공
  - MP3, AAC, Ogg

## 디지털 이미지

- 디지털 이미지는 그림 요소(picture element, pixel)로 이뤄진 직사각형 배열로 표현
- 각 픽셀은 빨간색, 녹색, 파란색의 조합
  - 오늘날 디스플레이는 보통 각 색에 8비트 사용
- 컴퓨터는 가산 혼합 색 시스템을 사용
- 포인트 샘플링: 정사각형 전체의 색을 기록하는 대신 각 정사각형의 중심 점의 색을 기록
- 슈퍼샘플링: 한 정사각형 안에서 여러 지점의 색을 얻어서 평균을 내는 방법

**JPEG**

- 가장 일반적인 이미지 압축 방식
- 연합 사진 전문가 그룹(Joint Photographic Experts Group)의 표준 압축 방식
- 이웃한 픽셀의 색이 서로 비슷할 확률이 높기 때문에 개별 픽셀의 색 대신 이웃 픽셀의 색을 저장하는 방법
- 두뇌는 색 보다는 **밝기 변화에 더 민감**하다는 사실을 활용

## 비디오

- 비디오는 2차원 이미지를 일정한 시간 간격으로 샘플링한 시퀀스
  - 오래된 영화는 초당 24 프레임, 요즘은 48fps(frame per second)
- 슈퍼 샘플링을 이용하면 불쾌한 시각적 아티팩트를 줄일 수 있음
- 움직임 보상(motion compensation): 비디오 프레임이 변할 때 보통 이미지의 **일부분만 변하므로** 변경된 영역의 데이터만 이용해 압축 가능하다.
  - 데이터가 왜곡되는 단점 존재
  - 정기적으로 데이터에 **키프레임(keyframe)**을 추가하면 데이터가 오염되어도 다음 키프레임에서 전체 이미지 복구 가능
- 레이어링: 레어어 간에 각기 다른 그림을 중첩시켜 비디오 이미지를 만듦

# 휴먼 인터페이스 장치

## 터미널

- 배치 프로세싱(batch processing): 키펀치를 사용해 종이에 코딩 양식을 찍어내고 이를 컴퓨터가 읽어 프로그램을 실행
- 텔레타이프(TTY)는 선의 끝에 연결되었기 때문에 터미널이라 불림
- **스레싱(thrashing)** 현상: 운영체제가 프로그램을 **스왑 인하고 스왑 아웃 하는 시간이 사용자 프로그램을 실행하는 시간보다 더 길어지는 현상**
  - 시분할 시스템이 아주 느려진다.
- 시분할 시스템은 한 번에 하나 이상의 작업을 하는 것과 같은 착각을 만듦 ⇒ 멀티태스킹
  - 많은 터미널이 같은 컴퓨터에 연결되기 시작해 어떤 작업이 누구에게 속했는지 구분하기 위해 사용자(user) 개념 탄생

## 그래픽 터미널

- 옛 그래픽 터미널은 CRT(cathode ray tube, 음극선관) 진공관의 변형
  - CRT 내부 유리에 화학적인 인광물질이 발라져 있고 여기 전자가 부딪히면 빛 발생
  - 그리드 또는 편향판(deflection plate)이 여럿 있으면 인광물질에 그림을 그릴 수 있다.
  - 편향판 버전: 정전기 현상과 같은 원리인 정전 편향(electrostatic deflection) 사용
  - 전자기를 사용한 버전: 전자 편향(electromagnetic deflection)
- 오늘날은 **액정 디스플레이(liquid crystal display, LCD)** 사용
  - 액정(액체 결정): 전기를 가하면 빛을 통과시키는 성질이 바뀌는 물질

## 벡터 그래픽

**CRT**

- 모눈종이처럼 x축 전압과 y축 전압에 따라 어떤 지점으로 이동하고 z축 전압으로 밝기 조절
- 원래 흑백이나 그레이스케일 디스플레이
- **인치당 표시할 수 있는 좌표 위치의 개수가 해상도(resolution)**

**벡터 그래픽**

- 선을 그려서 그림을 만듦
- 디스플레이 목록(display list): 그림을 그리는 명령어로 이루어진 목록
  - 마지막에는 첫 번째 목록으로 되돌아가 다시 시작해야 한다. 이는 화면상 이미지가 빠르게 사라지기 때문이다.
    - CRT 인광물질은 지속성(persistence)이 있어 계속 그림을 반복해 그리면 화면에 이미지가 표시된 상태를 유지할 수 있다.
- **플리커(flicker)**: 디스플레이 목록이 매우 길어지면 **화면이 깜박거린다.**

### 래스터 그래픽(raster graphics)

- 점으로 이뤄진 그래픽
- 래스터는 왼쪽 위에서 출발해 화면을 지나고 수평 리트레이스(horizontal retrace)를 통해 다음 줄의 최좌측으로 이동한다. 마지막 줄을 그린 후에는 수직 리트레이스(vertical retrace)를 통해 초기 상단 좌측으로 이동한다.
- 이 래스터가 달리는 동안 원하는 이미지를 표시하기 위해 정확한 시간에 정확히 밝기를 변화시키면 된다.
- 래스터 디스플레이는 실제 화면이라 점과 점 사이에 그림을 그릴 수 없다.
  - 이 때문에 불쾌한 시각적 아티팩트 발생

## 키보드와 마우스

- 키보드: 키 스위치를 격자상에 놓고 멀티플렉싱한 것으로 전원을 격자의 각 행에 순차적으로 인가하고 각 열의 입력을 받음
- 마우스: x와 y좌표를 담당하는 2개의 쿼드러처 인코더를 사용
- 터치 장치: 키보드와 비슷한 행 스캐닝과 열 스캐닝을 더 미세한 단위로 스캔
