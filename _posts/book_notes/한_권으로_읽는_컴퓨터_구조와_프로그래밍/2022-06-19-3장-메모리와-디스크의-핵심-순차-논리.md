---
title: "[한 권으로 읽는 컴퓨터 구조와 프로그래밍]3장 메모리와 디스크의 핵심: 순차 논리"
excerpt: "컴퓨터는 비트를 어떻게 기억하는가"
categories:
  - book_notes
tags:
  - 한_권으로_읽는_컴퓨터_구조와_프로그래밍
---

> 컴퓨터는 비트를 어떻게 기억하는가

# 서론

- 조합 논리는 입력에 의해서만 출력이 결정된다. 따라서 입력의 현재 싱태만을 다룬다.
  - 하지만 기억하는 능력이 없기 때문에 조합 논리만으로는 컴퓨터를 만들 수 없다.
- 순차 논리는 입력의 현재 상태와 과거 상태를 함께 고려한다.

# 시간 표현과 상태 기억

## 발진자

- 인버터의 출력을 입력에 연결 하는 경우 이러한 연결을 피드백이라 한다.
  - 출력이 0과 1 사이를 진동한다.
  - 진송하는 속도는 전파 지연에 따라 결정되며 온도에 따라 달라진다.
- 크리스털 발진자
  - 크리스털을 활용하면 좀 더 안정적인 주파수로 진동하는 정확한 발진자를 효율적으로 만들 수 있다.
    - 피에조 전기 효과(압전 효과)
      - 전극을 크리스털에 연결하고 크리스털을 압축하면 크리스털이 전기를 만듦
      - 전극에 전기를 가하면 크리스털이 구부러짐
  - 전자적인 단극쌍투 스위치를 사용해 크리스털에 전기를 가해서 다시 전기를 얻음
  - 입력한 전기로부터 크리스털이 다시 전기를 만들어 내는 시간은 예측 가능하며 매우 정확
- 따라서 발진자를 사용하면 시간을 잘 측정할 수 있다.

## 클록

> 시간을 셀 수 있게 해주는 신호

- 클록은 회로의 페이스(pace)를 결정한다.
  - 전파 지연은 회로가 작업을 수행하는 속도에 영향을 미친다.
    - 시간을 잴 수 있으면 지연 시간을 기다릴 수 있다.
    - 발진자는 컴퓨터에 클록을 제공한다.
  - 회로의 최대 클록 속도나 가장 빠른 템포는 회로의 전파 지연 시간에 의해 결정된다.

### 비닝(binning)

- 컴퓨터 컴포넌트를 이루는 부품을 편차에 따라 나누는 과정
- 지연 시간이 짧아 빨리 반응할 수 있는 정도와 가격에 따라 빈을 분류한다.
- 실용성을 위해 일정 편차로 나누어 빈에 담는다.
  - 부품의 전파 지연 시간을 표시할 때 범위를 사용한다.
  - 범위에는 전형적인 값과 함께 최솟값과 최댓값이 제공된다.
    - 오버클로킹: 빈의 중간 정보 위치하는 범위의 부품을 고장나지 않을 범위 안에서 클록을 빠르게 공급하는 도박

## 래치

- 1 비트의 정보를 기억하기 위해 사용

### OR 게이트 래치

- 하나의 입력에 더하여 출력이 입력에 묶인(피드백) OR 게이트는 정보를 기억할 수 있다.
  - 입력과 출력이 0으로 시작한다고 가정하면, 입력이 1이 되는 순간 출력이 1이 되고 이는 입력에 묶여 있기 때문에 OR 게이트의 출력은 계속 1로 유지된다.

### AND-OR 게이트 래치

- 출력을 다시 0으로 만들기 위해는 피드백을 끊고 회로를 재설정해야 한다.
  - AND 게이트에 OR 게이트 출력과 reset 입력값을 연결하고 게이트의 출력값을 OR 게이트의 입력과 연결한다.
  - reset이 로우이면 reset bar는 하이 즉, 1이고 AND 게이트의 출력은 OR 게이트의 출력에 의존한다.
    - 따라서 OR 게이트의 출력은 AND 게이트의 입력에 계속 피드백되어 영향을 준다.
  - reset이 하이이면 reset bar는 로우 즉, 0이고 AND 게이트의 출력은 항상 0이다.
    - 따라서 OR 게이트의 출력은 set과 같다.
    - 따라서 set이 1로 설정되면 출력은 계속 1로 유지되고 그렇지 않다면 0으로 초기화될 수 있다.

### S-R 래치

- 액티브 로우 입력을 받고 보수 출력(Q와 Q bar)을 제공
  - 보수 출력: 출력의 한 쪽은 액티브 하이, 한 쪽은 액티브 로우
  - NOR 게이트는 더 전력을 많이 사용하고 더 복잡하며 더 비싸서 NAND 게이트를 사용한다.
- set bar와 reset bar가 모두 로우인 경우 두 출력이 모두 참이 되므로 이러한 입력은 사용하지 않는다. 두 입력이 모두 하이인 경우에는 전파 지연 시간에 따라 출력이 달라지기 때문에 결과를 예측할 수 없다.
- S-R 래치는 회로가 대칭이기 때문에 set과 reset 신호의 지연 시간이 거의 비슷하다.
- S-R 래치는 초기값을 알 수 없다. 따라서 전원을 인가한 뒤 로직을 재설정해야 한다.

## 게이트가 있는 래치

- gate bar의 입력이 하이인 경우 set bar와 reset bar 입력과 무관하게 S와 R 게이트 입력이 모두 1이 되어 출력이 유지된다.

### 게이트가 있는 D 래치

- 1비트의 정보를 유지하기 위해 입력을 1비트만 받도록 만들 수 있다.
  - set bar와 reset bar를 같은 입력에 연결하고 한 쪽에만 인버터를 추가한다.
- gate bar가 로우일 때 D가 1이면 Q는 1이다. gate bar가 로우일 때 D가 0이면 Q는 0이다. gate bar가 하이일 때에는 D가 변해도 Q에 변화가 없다.

  | gate bar | D   | set bar | reset bar | Q      | Q bar      |
  | -------- | --- | ------- | --------- | ------ | ---------- |
  | low      | 1   | 0       | 1         | 1      | 0          |
  | high     | 1   | 1       | 1         | memory | memory bar |
  | low      | 0   | 1       | 0         | 0      | 1          |
  | high     | 0   | 1       | 1         | memory | memory bar |

- 이 회로는 gate bar가 로우인 경우 D의 변화가 출력에 그대로 나타나 문제가 된다.
  - 게이트가 열려있는 동안 D가 상태를 바꾸지 않는것이 바람직하므로, 게이트가 열린 시간을 최소화 해 D의 상태에 맞춰 출력 상태를 변경해야 한다.
  - 이는 데이터 변경으로 인해 잘못된 결과가 생길 수 있는 가능성을 최소화 한다.

## 플립플롭

- 위의 문제를 해결하기 위해 가장 일반적으로는 논리 수준이 특정 값에 머무는 동안 데이터를 잡아내지 않고, 논리 수준이 다른 수준으로 전이되는 중간에 데이터를 잡아낸다.
  - 이러한 전이를 에지(edge)라고 부른다. 에지를 시간에 대한 판정 기준이라고 생각할 수 있다.
  - 에지에 의해 데이터 변화가 촉발되는 래치를 플립플롭이라 한다.

### 양의 에지에 의해 변화가 촉발되는 플립플롭(D 플립플롭)

- 논리 수준이 0에서 1로 바뀌는 순간 플립플롭 출력이 바뀐다.

### D 플립플롭의 동작

- 클록을 0으로 설정한다. S bar와 R bar가 모두 high이기 때문에 D와 상관없이 그림 3-9의 우측 래치 상태는 바뀌지 않는다.
- R bar가 low인 경우 D의 값을 바꾸어도 효과가 없다(두 번째, 세 번째 그림)
  - NAND 게이트는 두 입력이 모두 1일 때에만 0을 출력한다.
- S bar가 low인 경우 D의 값을 바꾸어도 효과가 없다(네 번째, 다섯 번째 그림)
- 따라서 클록이 로우이거나 하이인 경우에는 D를 바꿔도 아무일도 일어나지 않는다.

### 양의 에지(클록이 0에서 1로 변할 때)에서 D 플립플롭의 동작

- 클록이 low이고 D가 high, S bar와 R bar가 모두 high일 때 아무 변화 없다(왼쪽 그림).
  - 하지만 클록이 1로 바뀌면 S bar가 low로 바뀐다. 즉 플립플롭의 상태가 바뀐다.
  - 따라서 클록 신호가 0에서 1로 바뀌는 시점에 D 입력의 값이 플립플롭에 저장된다.

### 설정 시간과 유지 시간

- 에지에 의해 상태 변화가 촉발되는 장치의 상태 변화 타이밍을 볼 때에는 전파 지연 외의 요소도 고려해야 한다.
- 설정 시간(setup time): 클록 에지가 발생하기 전 입력 신호가 안정적으로 유지되어야 하는 시간
- 유지 시간(hold time): 클록 에지가 발생한 이후 입력 신호가 안정적으로 유지되어야 하는 시간

- 클록 에지 근처의 설정, 유지 시간을 제외한 나머지 시간에는 D의 값이 무엇이든 출력에 영향이 없다.
- 출력은 전파 지연 시간이 지나야 D 입력과 무관하게 안정적으로 유지될 수 있다.
  - 이는 다른 모든 로직도 마찬가지이다.
- 일반적으로 설정 시간을 t_setup, 유지 시간을 t_hold라고 한다.

## 카운터

> 카운터를 사용하면 시간을 셀 수 있다.

### 리플 카운터

- signal이 0에서 1로 가는 횟수를 세어 3비트 수(C_2, C_1, C_0)를 만들어 1, 2, 3 순서대로 수를 센다. reset bar 신호를 사용하면 카운터를 0으로 재설정할 수 있다.
- C_0는 C_1를 바꾸고, C_1은 C_2를 바꾸는 식으로 왼쪽에서 오른쪽으로 퍼져나간다.
- 각 플립플롭의 D 입력이 자기 자신의 Q bar 출력에 연결되어 있기 때문에 각 플립플롭은 자신의 CK 신호가 0에서 1로 전이될 때마다 상태가 바뀐다.
- 각 비트의 상태가 다른 비트의 상태 변화에 시차를 두고 바뀌기 때문에 비동기 카운터라고도 한다.
  - 언제 결과를 살펴봐야 하는지 알기 어렵다는 단점 존재
  - 카운터의 상태가 퍼져나가는 동안 출력은 올바르지 않다.
  - 앞의 비트보다 뒤의 비트 결과를 얻는 데 더 오랜 시간이 걸린다.
  - 전파 지연이 허용하는 것보다 더 빠른 속도로 입력을 변화시키면 출력이 틀리는 경우도 생긴다.
  - 이러한 리플 카운터의 타이밍 문제를 해결하는 것이 동기적 카운터이다.

### 동기적 카운터

- 리플 카운터와 달리 상태 변경이 동시에 일어난다.
  - 플립플롭에 같은 클록을 병렬로 연결한다.
  - 전파 지연만 고려하면 된다.

### 카운터 스키매틱 기호

- CLR: 카운터를 0으로 되돌림
- EN: 카운터 활성화
  - 이 값이 참이 아니면 클록이 변하고 입력이 바뀌어도 카운터 값은 변하지 않는다.
- U/D bar: 1인 경우 개수를 증가시키고 0인 경우 감소시킨다.
- LD: 데이터 입력 D_0-n과 카운터를 데이터 입력에 지정한 값으로 설정하기 위함

## 레지스터

- 클록을 공유하는 여러 D 플립플롭을 한 패키지에 넣은 것
  - 하나의 비틀르 저장하는 플립플롭에 비해 레지스터는 여러 비트를 저장할 수 있다.
- 카운터와 비슷하게 EN(enable) 입력을 자주 제공한다.

# 메모리 조직과 주소 지정

- 더 많은 정보를 저장하기 위해선 레지스터를 쌓아놔야 한다.
- 디코더를 기본 요소로 사용해 레지스터에 주소를 부여할 수 있다.
  - 디코더의 출력을 레지스터의 입력을 활성화하기 위해 사용한다.
- 실렉터를 이용해 지정한 주소에 해당하는 레지스터의 출력을 선택할 수 있다.
- 트라이스테이트 출력을 이용해 시스템에서 여러 메모리 컴포넌트의 출력을 한 출력으로 연결할 수 있다.

- 메모리를 동시에 읽고 쓸 필요는 거의 없기 때문에 입력과 출력 데이터 연결을 합치고 read/write bar 제어 신호를 사용면 메모리 컴포넌트 회로의 연결을 많이 줄일 수 있다.

- enable 제어 신호는 메모리 전체를 켜거나 꺼서 여러 메모리 칩을 함께 연결할 수 있게 한다.
- 메모리 칩에는 주소 버스와 데이터 버스가 있다.
  - 버스는 비트를 이동시킨다.
- 메모리 칩은 내부에서 격자로 관리된다. 주소를 행과 열의 두 덩어리로 나누며 내부 위치는 열과 행을 조합해 지정된다.
  - 행과 열 주소를 멀티플렉싱하고 멀티플렉싱한 주소를 저장할 레지스터만 추가하면 주소 라인의 수를 반으로 줄일 수 있다.
  - 주소가 두 부분으로 나누어 들어오기 때문에 한 번에 한 부분씩만 변경할 수 있다면 성능이 더 좋아질 수 있다.

## 임의 접근 메모리(random access memory, RAM)

- 위에서 살표본 메모리는 임의 접근 메모리이다.
  - 메모리 위치 중 원하는 곳 어디든 원하는 순서로 읽거나 쓸 수 있다.

### 정적 RAM(SPAM)

- 비싸지만 빠르다.
- 각 비트에 트랜지스터가 6가 들어가고, 트랜지스터는 공간을 차지하기 때문에 수십억~수조 비트를 저장하기에 적합하진 않다.

### 동적 RAM(DRAM)

- 커패시터라는 작은 버킷에 전자를 담고 1개의 트랜지스터만 사용해 뚜껑을 덮는다.
  - 버킷은 새기 때문에 가끔 메모리를 갱신해야 한다. 즉 전자를 다시 채워야 한다.
    - 이미 비트가 들어있는버킷에 전자를 채우는 시점과 버킷에 정보를 쓰는 시간이 곂치지 않게 해야 한다.
  - 빛이 버킷에 비치면 버킷이 새는 속도가 더 빨라진다.
- 집적도가 높아 큰 메모리 칩에 사용
  - 큰 메모리 칩은 주소가 많기 때문에 주소 멀티플렉싱 방식을 사용
  - 행 주소 스트로브를 사용해 행 주소를 저장하는 속도 > 열 주소 스트로브로 열 주소 변경하는 속도
    - 페이지(행)를 넘기는 것보다 한 페이지에서 각 줄을 건너뛰는게 더 빠른 것과 비슷
    - 따라서 함께 사용되는 요소를 같은 행에 넣어두면 성능이 좋아진다.

### 휘발성 및 비휘발성

- SRAM과 DRAM은 휘발성 메모리다. 전원이 끊어지면 데이터가 사라진다.
- 코어 메모리는 비휘발성 RAM으로, 비트를 토러스 모양 쇳조각에 저장한다.
  - 토러스가 한 방향으로 자화되면 0, 반대 방향을 자화되면 1.
  - 토러스는 도넛 바깥쪽의 전자기 간섭에 대한 저항력이 아주 크다
  - 가로 세로 선이 통과하는 격자에 코어가 배열된 평면으로 배열된다.
  - 코어를 읽기 위한 세 번째 선, 감지 선이 존재
    - 자화 상태의 변화를 감지
  - 3차원 메모리

## 읽기 전용 메모리(read-only memory, ROM)

- 정확하게는 한 번만 쓸 수 있는 메모리(write-once memory) 표현이 더 맞다. 한 번 쓰면 여러 번 읽으르 수 있다.

### 홀러리스 카드(Hollerith card)

- 비트를 종이에 구멍으로 뚫어 표시
- IBM 카드
- 한 묶음(deck)을 떨어뜨리면 순서가 뒤섞여 데이터가 꼬일 수 있다.
- 물리적으로 움직여야 하기에 매우 느림

### 천공 종이 테이프(punched paper tape)

- 종이 롤에 뚫린 구멍이 비트를 표현
- 떨어뜨려도 순서가 꼬이지 않지만 수리가 어렵다.
- 물리적으로 움직여야 하기에 매우 느림

### 코어 로프 메모리(core rope memory)

- 바느질을 통해 비트를 기록해 전자기 간섭의 영향을 받지 않음
  - 우주에서 중요한 특성

### 마스크 프로그래머블 ROM

- 카드와 종이 테이프는 일정한 순서로만 읽을 수 있는 순차적 메모리지만 마스크 프로그래머블 ROM은 임의 접근이 가능하다. 즉 아무 주소나 원하는대로 읽을 수 있다.
- 마스크는 집적 회로 생산 과정에서 사용하는 공판화(stencil)이며 마스크가 바뀌지 않는 이상 내용도 바뀌지 않는다.

### 프로그래머블 읽기 전용 메모리(PROM)

- 마스크는 비용이 비싸 직접 프로그래밍할 수 있는 ROM이 만들어짐
- 최초의 PROM은 칩에 있는 니크롬 퓨즈를 녹이는 방식

### 지울 수 있는 읽기 전용 메모리(EPROM)

- 패키지 위쪽에 수정 창이 있어 특별한 자외선 빛을 사용해 저장된 내용을 지울 수 있다.

### 전기로 지울 수 있는 읽기 전용 메모리(EEPROM)

- 내부 데이터를 아무 순서로나 쓰고 읽을 수 있어 기술적으로는 RAM이지만 데이터를 쓰고 지우는데 시간이 오래 걸리며 RAM보다 비싸기 때문에 ROM을 대신하기 위해 사용한다.

# 블록 장치

**디스크 드라이브**

- 대량 저장장치
- 자화된 판(platter)에 비트를 저장
  - 코어 메모리와 마찬가지로 비휘발성
- 필요한 데이터는 디스크 헤드를 이용해 가져옴
- 다른 메모리에 비해 상대적으로 느림
  - 헤드를 지나간 데이터를 다시 가져오려면 한 바퀴의 회전을 기다려야 함
- 기계 부품이 점차 낡아짐
  - 회전축의 마찰을 줄이는 베어링이 마모됨
- 기록 밀도와 속도를 맞바꾼 기억 장치
  - DRAM 등과 달리 주소나 데이터 연결을 위한 공간이 필요 없음
- 바이트 대신 블록(sector) 단위로 수조를 지정해 읽음
  - 섹터는 읽고 쓰기가 가능한 가장 작은 단위
  - 모든 섹터에 동일한 비트가 들어있어 디스크 안쪽의 비트 밀도가 더 높아 낭비가 심하다.
    - 방사상 영역(radial zone)으로 디스크를 구분해 바깥쪽에 더 많은 섹터를 넣어 이를 해결한다.
- 헤드의 위치에 따라 트랙으로 나뉨
  - 탐색 시간(seek time): 헤드를 한 트랙에서 다른 트랙으로 옮길 때 걸리는 시간
  - 회전 지연 시간(rotational latency): 원하는 데이터가 헤드 아래로 올 때까지 디스크가 도는 시간

**플로피 디스크(floppy disk)**

- 디스크 드라이브(하드 드라이브)와 달리 더 저렴하고 탈착이 가능

**자기 드럼 저장장치(magnetic drum)**

- 회전하는 원통에 헤드가 줄지어 있는 기억장치

**자기 테이프(magnetic tape)**

- 자화시킨 테이프를 감은 릴(reel)을 사용하는 비휘발성 저장장치
- 디스크 드라이브보다 느리고 원하는 위치까지 테이프를 감으려면 오랜 시간 소요

**광학 디스크(optical disk)**

- 자기 디스크와 달리 데이터를 읽고 쓰기 위해 자성 대신 빛을 사용
- CD나 DVD
- 같은 데이터를 포함하는 데이터를 대량으로 찍어낼 수 있다. 미리 출력된 디스크는 ROM이다. PROM처럼 한 번만 쓸 수 있는 디스크, 지우고 다시 쓸 쑤 있는 디스크도 있다.

# 플래시 메모리와 SSD

**플래시 메모리(flash memory)**

- EEPROM 유형의 매체
- DRAM과 마찬가지로 버킷에 전자를 담는 방식으로 작동
  - DRAM보다 버킷이 크고 잘 만들어져 전자가 새지 않는다.
  - 하지만 여러 번 읽고 쓰기 위해 뚜껑을 여닫다 보면 뚜껑이 끊어진다.
- EEPROM보다 더 빨리 지울 수 있고 더 저렴하다.
- RAM처럼 원하는 위치를 마음대로 읽을 수 있다.
  - 하지만 빈 플래시 메모리에 먼저 0이 채워져있어야 한다. 또한 전체를 지우지 않고 원하는 비트만 1에서 0으로 되돌릴 수 없다.
  - 이를 위해 내부가 블록으로 나뉘고 불록 단위로 지우고 쓸 수 있다.
  - 따라서 읽을 때는 임의 접근 장치이고 쓸 때에는 블록 접근 장치이다.

**고체 상태 드라이브(solid-state drive)**

- 디스크 드라이브 모양의 패키지에 넣은 플래시 메모리
- 플래시 메모리는 점점 낡기 때문에 SSD는 블록의 쓴 횟수를 기록해 모든 블록이 비슷하게 낡게 조정(wear leveling)하는 프로세서를 포함한다.

# 오류 감지와 정정

**패리티(parity)**

- 패리티(parity)를 사용하면 1 비트만 데이터가 잘못된 경우 감지 가능
- 데이터에서 1로 설정된 비트의 개수를 세고 그 개수의 홀짝 여부를 나타내는 1 비트를 데이터에 덧붙임
  - 모든 비트의 XOR 연산 결과가 홀짝 여부를 나타내는 비트가 된다.
    - XOR 연산은 같을 때 0, 다를 때 1
- 짝수 패리티는 모든 비트를 XOR한 결과, 홀수 패리티는 XOR한 결과의 보수를 사용
  - 8비트 데이터에서 1이 4개 있다면 짝수 패리티는 패리티를 0으로 설정해 1을 4개로 유지하고 홀수 패리티는 패리티를 1로 설정해 1을 5개로 만든다.
- 미리 계산해 넣은 패리티와 데이터의 XOR 연산 결과 나온 패리티가 같으면, 즉 XOR 연산 결과가 0이면 문제가 없다는 뜻.
  - 하지만 오류가 짝수 번 발생하면 이를 구별할 수 없다.
- 끊임없이 변화하는 데이터를 처리할 때 유용하다.

**해밍 코드**

- 더 많은 비트를 사용해 더 많은 오류를 감지하고, 오류 횟수가 작으면 오류를 바로 수정 할 수 있다.
- 이를 내장한 오류 검사와 정정(error checking and correction, ECC) 메모리 칩이 있다.

**체크섬**

- 정적인 데이터 블록을 검증하는 값싼 방법
- 데이터의 각 지점을 n 비트 값으로 더하고 n 비트를 넘어가는 값은 무시한다.
- 체크섬에 사용하는 값이 클수록 즉, n이 클수록 위양성 결과가 발생하기 어렵다.

**순환 중복 검사(cyclic redundancy check, CRC)**

- 데이터의 고유성을 드러내는 방식으로 검증 숫자를 계산해 데이터가 바뀌면 검증 숫자가 일치하지 않게 만드는 법

# 하드웨어와 소프트웨어 비교

- 둘의 차이는 거의 없다.
- 펌웨어(firmware)는 원래는 ROM에 담긴 소프트웨어를 가르키는 용어였지만 현재는 플래시 메모리 상이나 RAM 상에도 존재한다.
- 초반의 칩 설계는 완전한 커스텀 설계였다. 이후 칩 제작 비용을 줄이기 위해 게이트 배열(gate array)을 도입했다.
  - 게이트 배열에는 미리 설계된 구성요소가 있고 구성 요소를 연결하는 금속 계층만 커스텀할 수 있다.
  - 게이트 배열도 직접 프로그래밍 할 수 있는 칩(PROM)으로 변화했고, 지우고 다시 프로그래밍할 수 있는 칩(EEPROM)도 존재한다.
- 현대적 FPGA(field-programmable gate array)는 플래시 메모리에 해당하는 논리 칩이다.
  - 소프트웨어로 로직을 지우고 다시 프로그래밍할 수 있다.
  - 저렴하다.
