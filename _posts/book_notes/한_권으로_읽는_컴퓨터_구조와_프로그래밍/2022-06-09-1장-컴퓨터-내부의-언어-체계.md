---
title: "[한 권으로 읽는 컴퓨터 구조와 프로그래밍]1장 컴퓨터 내부의 언어 체계"
excerpt: "컴퓨터는 어떤 말을 사용할까"
categories:
  - book_notes
tags:
  - 한_권으로_읽는_컴퓨터_구조와_프로그래밍

last_modified_at: 2022-06-09

toc: true
toc_sticky: true
toc_label: "목차"
---

> 컴퓨터는 어떤 말을 사용할까

# 언어란 무엇인가

- 모든 언어의 뜻은 기호의 집합으로 인코딩됨
- 당사자들은 모두 같은 문맥을 공유해 기호에 같은 뜻을 부여해야 함

# 문자 언어

- 문자 언어는 기호를 나열한 것
- 문자 언어의 세 가지 구성요소
  - 기호가 들어갈 상자
  - 상자에 들어갈 기호
  - 상자의 순서

# 비트

- binary + digit
- 2진법을 사용

# 논리 연산

- 다른 비트들이 표현하는 내용으로부터 새로운 비트를 만들어내는 동작

## 불리언 대수

- NOT, AND, OR, XOR

## 드모르간의 법칙

- a AND b는 NOT(NOT a OR NOT b)와 같다.
- 즉 NOT을 충분히 사용하면 AND 연산을 OR 연산으로, OR 연산을 AND 연산으로 대신할 수 있다.

# 정수를 비트로 표현하는 방법

## 양의 정수 표현

- 10진수는 밑이 10인 시스템, 2진수는 밑이 2인 시스템
- 2진수에서 가장 오른쪽의 비트를 가장 작은 유효 비트(LSB)라 하고 가장 왼쪽의 비트를 가장 큰 유효 비트(MSB)라고 한다.
  - 비트가 바뀔 때 수를 가장 크게, 가장 작게 변화시킨다는 의미
- 어떤 값을 표현하는 데 필요한 최소 상자 개수보다 더 많은 상자가 존재할때, 그 상자를 채운 0을 리딩 제로(leading zero)라 한다.
  - 컴퓨터는 미리 정해진 수의 비트를 한 덩어리로 사용하도록 만들어졌기 때문

## 2진수 덧셈

- 두 비트를 서로 더한 결과 == 두 비트를 AND 한 올림 값 + 두 비트를 XOR 한 값
- 오버 플로
  - 덧셈 결과 사용 가능 비트 범위를 넘어가는 경우
  - 조건 코드(상태 코드) 레지스터에는 오버플로 비트가 있어 MSB에서 발생한 올림값을 담아둬 오버플로의 발생여부를 판단할 수 있다.

## 음수 표현

### 부호와 크기

- 한 비트를 부호에 사용하고 나머지 비트를 수의 크기, 즉 0부터의 거리(절댓값)를 표현하기 위해 사용
- 두 가지 한계 존재
  - 0을 표현하는 방법이 두 가지라 낭비이다.
  - XOR과 AND를 통한 덧셈을 할 수 없다.

### 1의 보수

- 양수의 모든 비트를 뒤집어 음수에 할당
- 두 가지 한계 존재
  - 0을 표현하는 방법이 두 가지이다.
  - 덧셈을 하려면 MSB에서 올림이 발생한 경우 이를 LSB로 전달하는 순환 올림(end-around carry)를 해야 한다. 따라서 이를 위한 하드웨어가 추가로 필요하다.

### 2의 보수

- 각 비트에 NOT을 취하고 1을 추가한 값을 음수로 할당한다.
  - MSB에서 올림이 발생하면 그 값은 버린다.
- 한 가지 방법으로 0을 표현한다.

# 실수를 표현하는 방법

## 고정소수점 표현법

- 소수점의 위치를 임의로 정함
- 쓸모 있는 범위의 실숫값을 표현하기 위해 필요한 비트의 개수가 너무 많아 잘 사용하지 않음

## 부동소수점 표현법

- 과학적 표기법을 2진수에 적용한다.
  - 10진 소수점 왼쪽이 한 자리뿐인 소수(가수, mantissa)에 10을 몇 번(지수, exponent) 거듭제곱 했는지로 표현
- 지수와 가수를 분리해 소수를 표현할 때 0을 다 안적어도 된다.
- 비효율적인 부분
  - 같은 값을 표현하는 방법이 여러가지이다.
  - 지수가 커질수록 가수의 한 패턴과 다른 패턴 사이의 값 차이가 커져 모든 수를 표현하지 못한다.

## IEEE 부동소수점 수 표준

- IEEE 754 표준은 부동소수점에 관한 기능을 정의한다.
  - 가수와 지수에 대해 각각 부호 비트를 사용하는 등의 내용
- 정밀도를 높이는 방법
  - 정규화
    - 정규화: 가수를 조정해 맨 앞에 0이 없도록 만듦
      - 이를 위해서는 지수도 조정해야 한다
  - 디지털 이퀍먼트 사에서 고안한 방법
    - 가수의 맨 왼쪽 비트가 1이라는 사실을 알고 있으므로 이를 생략
      - 가수에 1비트를 더 사용할 수 있다.
- 자주 쓰이는 두 가지 부동소수점 수
  - 기본 정밀도(single precision) 부동소수점 수(단정도 실수)
    - 32비트 사용, 7비트 정밀도
    - 약 ±10^38의 범위 표현
  - 2개 정밀도(double precision) 부동소수점 수(배정도 실수)
    - 64비트 사용, 15비트 정밀도
    - 약 ±10^308의 범위 표현
    - 비트를 2배 더 많이 사용한다. 즉 비싸다.
  - 두 형태 모두 가수에 대한 부호 사용
- 편향된(biased) 지숫값
  - 지수 비트가 모두 0이거나 1인 경우 특별한 의미를 부여하고 실제 지숫값은 나머지 비트 패턴에 포함
  - 지수에 대한 부호 비트를 넣지 않을 수 있음
  - 기본 정밀도의 편향값은 127, 2배 정밀도의 편향값은 1023
    - 기본 정밀도에서 127(01111111)이 지수 0을 표현한다.
- 여러가지 특별한 비트 패턴 제공
  - 0으로 나눴을 때 생기는 양 또는 음의 무한대를 표현하는 등의 비트 패턴
  - NaN도 포함
  - 모든 비트가 0이거나 1인 특별한 지숫값을 사용해 표현

# 2진 코드화한 10진수 시스템(binary-coded decimal)

- BCD는 4비트를 사용해 10진 숫자를 하나 표현
  - 예를 들어 12는 BCD로 0001 0010이다.
- 2진수를 효율적으로 활용하지 못한다.

# 2진수를 다루는 쉬운 방법

## 8진 표현법

- 2진수 비트를 3개씩 그룹으로 묶는다.
  - 100 101 110 001 010 100 ⇒ 456124

## 16진 표현법

- 요즘 컴퓨터 내부는 8비트의 배수를 사용하기 때문에 8진 표현법보다 더 널리 쓰인다.
  - 8진수 한 자리는 3 비트를 사용하고 8의 배수는 3으로 나누어 떨어지지 않기 때문
- 1101 0011 1111 1100 0001 ⇒ d3fc1

## 프로그래밍 언어의 진법 표기법

- 0으로 시작하는 숫자는 8진 숫자다.
  - 017은 8진수이며 10진수로 15이다.
- 1로부터 9 사이의 숫자로 시작하는 숫자는 10진수다.
- 0x가 앞에 붙은 숫자는 16진수다.
- 몇몇 언어는 0b를 붙여 2진수를 표기한다.

# 비트 그룹의 이름

- 바이트: 8비트
- 킬로비트, 킬로바이트: 1024 비트
- 키비(KiB), 메비(MiB), 기비(GiB), 테비(TiB)

# 텍스트 표현

## 아스키 코드

- 키보드에 있는 모든 기호에 대해 7비트 수 값을 할당
- 제어 문자
  - 글자 출력이 아닌 장치 제어를 위해 사용되는 문자

## 다른 표준의 진화

- ISO-646, ISO-8859를 도입해 영어 외의 유럽 언어를 지원
- 유니코드
  - 비트 가격이 떨어져 7비트나 8비트에 문자를 욱여넣을 필요가 없어졌기 때문에 문자에 16비트를 부여
  - 이후 21비트로 확장

## 유니코드 변환 형식 8비트(UTF-8)

- 컴퓨터는 8비트를 사용해 아스키 문자를 저장
- 유니코드도 인코딩을 통해 8비트로 저장
  - 인코딩: 다른 비트 패턴을 표현하기 위해 사용하는 비트 패턴
- 아스키 데이터를 인코딩할 때는 추가 공간 불필요
- 문자를 8비트 덩어리, 옥텟이라는 시퀀스로 인코딩
  - 첫 번째 옥텟의 MSB쪽 비트들이 옥텟의 시퀀스 길이 표현
  - MSB쪽의 비트 패턴이 곂치지 않아 옥텟 맨 앞을 식별하기 쉬움
  - 7비트 안에 문자의 코드가 들어가면 옥텟을 하나만 사용하고 MSB를 0으로 설정

# 문자를 사용한 수 표현

## 출력 가능하게 변경한 인코딩(Quoted-Printable encoding)

- 출력 가능 = 아스키 코드에서 제어 문자가 아닌 문자
- 8 비트 데이터를 7 비트 데이터만 지원하는 통신 경로를 통해 송수신하기 위한 인코딩 방법
- 전자우편 첨부를 위해 만들어짐
- = 다음에 바이트의 각 니블을 표현하는 16진 숫자 2개를 추가해 8비트값을 표현
- QP 인코딩은 1바이트 표현을 위해 3바이트를 사용해 비효율적

## 베이스64 인코딩

- QP 인코딩보다 효율적
- 3바이트 데이터를 4문자로 표현
  - 24비트를 네 가지 6비트 정어리로 나누고 각 덩어리의 6비트값에 출력 가능한 문자를 할당해 표현
- 모든 3바이트 조합을 4바이트 조합으려 변환 가능
- 패딩 문자
  - 원본 데이터가 2바이트 남으면 끝에 =을 붙이고 1바이트가 남으면 ==을 붙임

## URL 인코딩(퍼센트 인코딩)

- % 뒤에 어떤 문자의 16진 표현을 덧붙이는 방식으로 인코딩
- 특별한 기능에 해당하는 문자의 의미를 빼고 문자만 쓰는 경우 사용
  - `/` 문자의 아스키 코드는 47, 16진수로는 2F다. URL에서 `/`의 의미를 빼고 문자만 사용하고싶은 경우 %2F로 대신한다.

# 색을 표현하는 방법

- 컴퓨터 그래픽스: 전자 모눈종이에 해당하는 것에 색을 표현하는 점(blob)을 찍어서 그림을 만드는 과정
  - 격자에 찍는 점이 픽셀(picture element ⇒ pixel)
- RGB색 모델: 빨간색, 녹색, 파란색 광선을 섞어 색을 만듦
- 컬러 큐브: 색을 표현
  - 각 축은 primary 색을 표현하며 0이면 빛이 없고, 1이면 최대 밝기이다.
  - 가산 색 시스템
    - 빛을 섞을수록 더 밝은 색이 나온다. 모두 끄면 검은색, 모두 최대로 켜면 흰색이다.
    - 특정 빛의 파장을 서로 추가해 색을 만듦
    - 감산 시스템보다 더 많은 색을 만들 수 있음
  - 감산 색 시스템: 흰색 광선에서 각 색에 해당하지 않는 빛을 제거하며 색을 만듦
- 현대 컴퓨터는 색을 표현하는데 24비트를 사용
  - 세 가지 8비트 필드로 나뉘며 각 필드는 세 가지 주요 색을 표현
  - 현대 컴퓨터가 24비트 단위로 계산하지는 않기 때문에 가장 가까운 표준 크기인 32비트에 색을 넣어 처리
    - 남은 8비트는 투명도를 처리

## 투명도 추가

- 각 필셀에 알파라는 투명도 값 추가
  - 0 이상 1 이하 값으로 0은 완전 투명, 1은 완전 불투명
- 합성 계산법: 여러 다른 알파값의 색을 합성해 새로운 색을 만드는 방법
- 부동소수점 수를 사용하지 않았기에 1부터 255까지의 값을 알파 값으로 사용
- 이미지 합성은 색값을 알파로 곱하는 과정

## 색 인코딩

- 웹에서는 16진 트리플렛(hex triplet)으로 색을 표현
  - `#` 뒤에 여섯 자리 16진 숫자를 추가해 표현
  - 각각의 8비트 색값을 두 자리 문자로 된 16진 표기로 바꿈
