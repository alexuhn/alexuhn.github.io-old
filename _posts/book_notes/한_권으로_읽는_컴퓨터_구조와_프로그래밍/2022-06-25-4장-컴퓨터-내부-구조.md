---
title: "[한 권으로 읽는 컴퓨터 구조와 프로그래밍]4장 컴퓨터 내부 구조"
excerpt: "컴퓨터 하드웨어는 어떻게 구성되는가"
categories:
  - book_notes
tags:
  - 한 권으로 읽는 컴퓨터 구조와 프로그래밍
---

> 컴퓨터 하드웨어는 어떻게 구성되는가

# 서론

- 컴퓨터: 전자 부품을 다양하게 조합해 비트를 조작하는 회로
- 컴퓨터의 구성
  - 메모리
  - 입력과 출력
  - CPU

# 메모리

- 컴퓨터에서 조작할 비트를 저장할 장소
  - 바이트를 저장할 수 있고 주소가 부여되어 있다.
  - 메모리 위치(memory location): 구체적인 주소에 있는 메모리
- 32비트 컴퓨터는 보통 메모리를 4바이트 덩어리, 64비트 컴퓨터는 8바이트 덩어리로 구성
  - 덩어리가 크면 더 많은 양의 데이터 처리 가능
  - 주소는 바이트별로, 워드별로도 지정 가능
  - 정렬이 맞지 않는 접근: 한 번에 두 건물에 걸쳐 있는 데이터를 읽는 경우
- 다양한 종류 존재
  - SPAM은 빠르고 비싸며 디스크는 느리고 저렴하다.

**엔디안**

- 리틀 엔디안: 0번 바이트가 가장 오른쪽
- 빅 엔디안: 0번 바이트가 가장 왼쪽
- 한 시스템에서 다른 시스템으로 데이터 전송시 고려해야 함

# 입력과 출력

- I/O장치 = 주변 장치(peripheral device) = 퍼리퍼럴(peripheral)
- 과거에는 메모리 버스 경로와 I/O 버스 경로를 분리했지만 현대에는 메모리 주소 수가 많아지며 빈 주소도 많아졌기에 같은 버스 경로를 사용한다.
- 표준 입력/출력 슬롯
  - 일관된 방식으로 I/O 장치 연결
  - 각 슬롯을 차지한 장치는 자신에게 할당된 모든 주소 사용 가능
  - 각 슬롯에는 CPU에서 각 슬롯에 어떤 장치가 연결되었는지 파악할 때 쓰는 특별한 주소 존재

# 중앙 처리 장치

- 실제 계산을 처리하는 컴퓨터 부품

## 산술 논리 장치(Arithmetic logic unit, ALU)

- 산술 계산, 불리언 대수 및 기타 연산 수행
- 구성
  - 피연산자: 수를 표현하는 비트
  - 연산 코드(명령 코드, opcode): 피연산자에 대해 ALU가 어떤 연산자를 적용할지 지정
  - 결과: 피연산자에 연산자를 적용한 결과
  - 조건 코드: 결과에 대한 추가 정보
    - 조건 코드 레지스터: 조건 코드 저장
      - 레지스터: 메모리 거리가 아닌 다른 곳에 존재하는 메모리
      - 일부는 사용하지 않음
      - N 비트는 마지막으로 수행한 연산 결과가 음수인 경우 1
      - Z 비트는 마지막 연산 결과가 0인 경우 1
      - O 비트는 마지막 연산에서 오버플로나 언더플로가 생긴 경우 1

## 시프트

- 왼쪽 시프트로 인해 사라지는 MSB 값이나 오른쪽 시프트로 인해 사라지는 LSB 값을 조건 레지스터에 저장
- 부동소수점 연산의 핵심
  - 두 피연산자 가수를 지수에 따라 시프트해 소수점을 정렬한 뒤 더하거나 뺌

### 시프트 레지스터

- 시프트 명령어를 제외한 ALU의 모든 기능은 조합 논리로 구현 가능하며, 클록에 따라 1비트씩 시프트하는 시프트 레지스터는 플립플롭을 이용해 만들 수 있다.
- 순차적인 시프트 레지스터는 1비트를 시프트할 때 한 클록이 필요하기 때문에 여러 비트를 시프트를 하는 경우 느리다.
  - 실렉터와 조합 논리를 사용하는 배럴 시프터(barrel shifter)를 사용해 이를 해결 가능

### 배럴 시프터

- 8비트 시프터를 만들려면 8:1 실렉터가 8개 필요
  - 한 비트당 하나의 실렉터 필요
- S가 000이면 시프트를 하지 않고 001이면 오른쪽으로 1비트 시프트, 010이면 2비트 시프트

## 실행 장치(execution unit)

- 다른말로 제어 장치(control unit)
- 메모리의 정해진 장소에서 명령코드와 피연산자를 가져와 ALU에게 어떤 연산을 수행할지 알려주고 결과를 메모리에 돌려줌
- 프로그램 저장 방식 컴퓨터(stored-program computer)
  - 메모리에서 명령어를 찾음
  - 명령어: 컴퓨터에게 어떤 일을 할지 알려주는 비트 패턴
    - CPU마다 고유한 설계이며 공통 표준이 없다.

### 프로그램 카운터

- 메모리에서 명령어를 가져와야 하는 위치를 알기위해 사용한다.
  - 즉 메모리 주소가 들어있다 ⇒ 프로그램 카운터는 메모리 위치를 가리킨다(참조한다).
- 레지스터의 일종이며 메모리와 별도로 위치
- 순수 레지스터 대신 카운터로 이뤄진다. 즉 카운터 기능이 추가된 레지스터이다.
- 실행장치는 프로그램 카운터가 가리키는 주소에서 명령어를 읽어온다.
  - 명령어를 수행한 뒤 다음 명령어를 다음 위치에서 가져올 수 있도록 프로그램 카운터가 증가(increment)된다. 즉 명령어 크기가 프로그램 카운터에 더해진다.
- 리셋 벡터: CPU마다 정해진 초기 프로그램 카운터 값
  - CPU에 전원이 들어오면 이 값으로 설정

# 명령어 집합

## 명령어

### 3주소 명령어

- 명령어를 명령코드, 두 피연산자, 결과라는 네 가지 필드로 나눔
- 피연산자 주소에 너무 적은 비트만을 쓰는 단점 존재
- 세 가지 메모리 위치를 한꺼번에 지정하는 메모리 주소 접근 사용 또한 단점
  - 세 메모리 블록은 각기 다른 장치에 존재하며 주소 버스와 데이터 버스가 3개씩 따로 존재
  - 연산결과를 다른 연산에 사용하려면 결과가 들어있는 메모리 장치에 있는 데이터를 다른 피연산자 메모리 장치로 보내기 위한 별도의 명령어 필요
  - CPU 패키지의 입출력 핀 수가 제한되어 있기에 세 버스가 같은 핀을 공유하고 다른 클록에서 작동해야 함 ⇒ 버스를 3벌이나 둘 필요 없음 ⇒ 데이터 버스와 주소 버스를 하나만 두고 메모리 장치 공유
  - 회로가 복잡해지고 명령어 처리에 네 클록이 필요

### 주소 확장 레지스터

- 주소 확장 레지스터를 두고 별도의 명령어를 사용해 상위 주소(주소에서 MSB에 가까운 비트들)를 지정
- 인텔에서는 PAE(physical address extension, 물리 주소 확장)이라 부름
- 시간이 더 들고 여러 번 레지스터를 설정해야 하는 단점 존재

### 1주소 명령어

- ALU가 계산한 결과를 저장하는 누산기 이용
  - 누산기에 있는 값을 메모리에 저장하기 위한 저장 명령어가 추가로 필요
- 더 많은 주소 비트 사용 가능

## 주소 지정 모드

- 직접 주소 지정(direct addressing): 사용할 주소가 명령어에 직접 들어가 있음
- 간접 주소 지정(indirect addressing): 명령어에 피연산자 주소를 얻을 수 있는 메모리 주소를 가르키는 값을 추가
  - 더 많은 메모리 사용 가능
- 즉시 주소 지정 모드(immediate addressing mode): 주소에 해당하는 비트를 그냥 값으로 간주
- 속도는 즉시 주소 지정이 가장 빠르고 간접 주소 지정이 가장 느리다.

## 조건 코드 명령어

- cca: 조건 코드 레지스터의 값을 레지스터로 복사
- acc: 누산기의 값을 조건 코드 레지스터에 복사

## 분기 명령어

- 프로그램 카운터의 값을 변경하는 명령어
- 조건을 저장하기 위한 비트 필요
- pca: 현재 프로그램 카운터 값을 누산기에 복사
- apc: 누산기의 값을 프로그램 카운터에 복사

## 최종 명령어 집합 구성

- 모드, 명령코드, 주소로 구성
- 세 가지 주소 지정 모드 선택을 위한 2비트 할당 ⇒ 네 번째 모드는 메모리와 관계없는 연산 표현
- 프로그램: 어떤 목표를 달성하는 일련의 명령어

# 마지막 설계

## 명령어 레지스터

### 상태 기계

- 명령어를 실행하기 위해 컴퓨터에서 벌어지는 일
- 페치: 명령어를 메모리에서 가져옴
- 가져온 명령어를 실행하기 위해선 주로 메모리에 접근해야 한다.
  - 패치한 명령어에 쉽게 접근할 수 있도록 저장할 다른 위치가 필요하다.
  - 명령어 레지스터는 현재 실행중인 명령어를 저장한다.

## 데이터 경로와 제어 신호

- 프로그램 카운터의 값을 메모리 주소 버스에 넣을 방법과 메모리에 있는 데이터를 명령어 레지스터로 넣는 방법
  - 간접 주소 레지스터: 간접 주소 지정을 할 때 메모리에서 읽어온 주소 저장
- 레지스터에 데이터를 저장하거나 프로그램 카운터, 메모리가 수행하는 동작은 클록에 맞춰 수행되며 실렉터 등 다른 부분은 순전히 조합 논리이기 때문에 클록이 필요하지 않다.

## 데이터 흐름 제어

- 어떤 명령어든 처리를 위해 페치를 해야하며 페치를 위한 신호는 다음과 같다.
  - address source는 프로그램 카운터를 선택해야 한다.
  - 메모리를 동작시켜야 한다(enable을 1로 함). r/w bar는 읽기로 설정해야 한다.
  - 명령어 레지스터를 동작시켜야 한다(enable을 1로 함).
- 페치와 실행해는 여러 단계가 필요해 각 단계를 추적할 카운터가 필요

  - 카운터의 내용과 명령어의 명령코드와 모드 부분이 제어 신호를 결정
  - 가장 복잡한 연산의 경우 3단계가 필요해 카운터는 2비트 카운터여야 한다.

- 랜덤 논리: 복잡한 구조를 구현할 때 정해진 개수의 입력이 있고 이 입력을 정해진 개수의 출력에 연관시켜야 하는데 출력에 어떤 규칙성이 없는 경우 회로도가 얽히고설킨 것 처럼 보인다. 그래서 랜덤이라 한다.

- 랜덤 논리 대신 적당한 크기의 메모리를 사용할 수도 있다. 카운터의 출력과 명령어의 명령 코드와 주소 지정 모드 부분은 메모리 주소에 연결된다.
  - 이는 상태 기계이고 프로그래밍이 가능하기 때문에 컴퓨터이다.
  - 이런식으로 구현하는 방법을 마이크로코드를 썼다고 한다. 메모리의 내용이 마이크로코드다.
    - 마이크로코드 메모리로 ROM을 쓰면 좋다. 그렇지 않는다면 어딘가 저장했다가 필요할 때 불러오는 회로가 필요하다.

# RISC와 CISC 명령어 집합

- Reduced Instruction Set Computer
  - 복잡한 명령어를 단순한 명령어를 조합해 처리
  - 적재-저장 구조(load-store architecture)를 사용
  - 메모리와 레지스터를 오가는 명령어들과 레지스터 간 명령어로만 이루어짐
- Complicated Instruction Set Computer
  - 디지털 이퀍먼트사의 PDP-11
    - ALU 역할을 할 수 있는 범용 레지스터 8개 존재
    - 자동증가, 자동감소 주소 지정 모드 지원
      - 레지스터를 사용하기 전이나 후에 레지스터에 들어있는 값을 감소시키거나 증가시켜주는 모드
      - C 언어의 포인터와 자동증가, 자동감소를 쉽게 기계어로 번역 가능
    - C 언어가 처음 만들어짐

# GPU(graphics processing unit)

- 그래픽 처리는 일반적 용도의 CPU가 제공하는 모든 기능이 필요하지 않음
- 그래픽처리는 여러 점을 동시에 찍으면 성능이 향상될 수 있어 병렬화(parallelize)하기 좋은 작업
- 두 가지 특징
  - 간단한 처리 장치가 아주 많이 들어있다.
  - CPU보다 메모리 버스의 폭이 넗다 ⇒ 메모리에 더 빠르게 접근할 수 있다.
