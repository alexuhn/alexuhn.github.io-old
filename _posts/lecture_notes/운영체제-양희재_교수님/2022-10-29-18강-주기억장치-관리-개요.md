---
title: "[운영체제-양희재 교수님]18강 주기억장치 관리 개요"
excerpt: "메모리 관리에 대한 개요"
categories:
  - lecture_notes
tags:
  - 운영체제-양희재 교수님
---

[경성대학교 양희재 교수님의 운영체제 18강](http://www.kocw.net/home/cview.do?lid=25aa290afc4c5d78)


# 메모리 역사

- 메모리 역사
    - Core memory
    - 진공관 메모리
    - 트랜지스터 메모리
    - 집적회로 메모리
        - SRAM, DRAM
- 메모리 용량
    - 1970년대: 8-bit PC 등장, 메인 메모리 64KB
    - 1980년: 16-bit IBM-PC 등장, 메인 메모리 640KB → 1MB → 4MB 증가
    - 1990년: 수 MB → 수십 MB 증가
    - 2000년 이후: 수백 MB → 수 GB 증가
- 과거에는 메모리 용량이 너무 부족해 메모리 관리가 매우 중요했다.

## 언제나 부족한 메모리

- 프로그램 변천
    - 과거에는 기계어/어셈블리어를 작성했지만 이후 C언어, 자바, 객체 지향형 언어 작성
    - 숫자 처리 → 문자 처리 → 멀티미디어 처리 → Big Data 처리
- 메모리 용량도 증가하지만 그만큼 프로그램 크기도 증가 ⇒ 언제나 부족한 메모리
- 메모리의 효율적 사용
    - 메모리 낭비 없애기
    - 가상 메모리 (virtual memory)

# 프로그램을 메모리에 올리기

- 메모리 구조
    - 입력 ⇒ 주소(Address)
    - 출력 ⇒ 데이터(Data)
- 프로그램이 개발되는 방식
    - 원천 파일(Source file): 고수준 언어 또는 어셈블리 언어로 작성
    - 목적 파일(Object file): 원천 파일을 컴파일 또는 어셈블리한 결과
        - 원천 파일 → 컴파일러 → 목적 파일
        - 원천 파일 → 어셈블러 → 목적 파일
    - 실행 파일(Executable file): 라이브러리와 목적 파일을 링크한 결과
        - 목적 파일 → 링커 → 실행 파일
        - 구조 ⇒ code(기계어) + data(변수 등) + stack(지역 변수 등)
        - 이후 로더가 실행 파일을 메인 메모리에 적재한다.
- 실행 파일을 메모리에 올릴 때 고려해야 할 사항
    - 메모리의 몇 번지에 올릴 것인가 ⇒ OS가 결정
    - 다중 프로그래밍 환경에서는 몇 번지에 올릴 것인가 ⇒ MMU 사용
        - CPU와 메모리 사이에 존재하는 MMU는 재배치 레지스터(Relocation register)를 가지고 있다.
        - 재배치 레지스터를 이용해 개발 단계에서 지정한 메모리 번지수와 실제 적재될 메모리 번지수를 조정 ⇒ address translation
- 주소의 종류
    - 논리 주소(logical address)
        - CPU가 보는 주소
        - MMU가 이를 물리 주소로 바꾼다.
    - 물리 주소(physical address)
        - 실제 메인 메모리에 들어가는 주소