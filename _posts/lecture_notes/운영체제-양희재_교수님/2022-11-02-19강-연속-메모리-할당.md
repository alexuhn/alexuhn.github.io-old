---
title: "[운영체제-양희재 교수님]19강 연속 메모리 할당"
excerpt: "연속 메모리 할당, 페이징, 주소 변환에 대하여"
categories:
  - lecture_notes
tags:
  - 운영체제-양희재 교수님
---

[경성대학교 양희재 교수님의 운영체제 19강](http://www.kocw.net/home/cview.do?lid=cbbb7ca31741c840)

# 연속 메모리 할당(Contiguous Memory Allocation)

- 다중 프로그래밍 환경
    - 부팅 직후 메모리 상태 ⇒ OS + big single hole(OS 이외의 빈 공간)
    - 프로세스 생성과 종료 반복 ⇒ scattered holes(종료된 프로세스가 남긴 공간)
- 메모리 단편화(Memory fragmentation)
    - Hole이 **불연속적**으로 흩어져 있기 때문에 프로세스 적재 불가 
    ⇒ 외부 단편화(external fragmentation) 발생

## 연속 메모리 할당 방식

- 외부 단편화를 최소화하기 위해 할당 방식 고안
    - First-fit(최초 적합): 들어갈 수 있는 공간 중 제일 처음 만나는 위치에 할당
    - Best-fit(최적 적합): 들어갈 수 있는 공간 중 가장 차이가 적은 위치에 할당
    - Worst-fit(최악 적합): 들어갈 수 있는 공간 중 가장 차이가 큰 위치에 할당
- 할당 방식에 따른 성능 비교
    - 속도 기준 ⇒ first-fit
        - 처음 만나는 지점에 할당하니 가장 빠르다.
    - 이용률 기준 ⇒ first-fit, best-fit
- 할당 방식을 바꾸어도 외부 단편화로 인해 전체 메모리의 약 1/3을 사용 불가 ⇒ 다른 방법 필요

## Compaction

- 앞서 살펴본 메모리 할당 방식으로도 막지 못하는 낭비를 없애기 위한 방법
- 불연속적으로 흩어진 hole을 모두 한곳으로 모으는 작업 ⇒ 고부담
- Hole을 모으는 데 사용될 최적의 알고리즘 부재

# 페이징(Paging)

- 프로세스를 메모리에 연속으로 할당하지 말자.
- 프로세스를 일정 크기로 잘라서 메모리에 할당
    - 프로세스를 자른 것 ⇒ 페이지(page)
    - 메모리를 자른 것 ⇒ 프레임(frame)
    - 페이지의 크기 = 프레임의 크기
- 프로세스가 잘렸는데도 정상 작동되는가?
    - 프로세스는 메모리에 연속적으로 할당되어 있어야 한다. 따라서 CPU를 속여야 한다.
    - MMU에 relocation Register를 여러 개를 두고 레지스터 값을 바꿈 
    ⇒ CPU 입장에선 메모리에 연속으로 할당된 것처럼 보임
    - Logical address는 연속적이고 physical address는 불연속적으로 된다.
- 페이지 테이블(page table)
    - 페이징 목적으로 사용하는 MMU
    - 재배치 레지스터가 여러 개 존재

# 주소 변환(Address Translation)

- 논리 주소
    - CPU가 내는 주소
    - 2진수로 표현
    - 주소가 전체 `m` 비트라고 가정할 때,
        - 하위 `n` 비트 ⇒ 오프셋(offset) 또는 변위(displacement)
        - 상위 `m-n` 비트 ⇒ 페이지 번호(`p`)
- 논리 주소 → 물리 주소 변환
    - 페이지 번호 `p` ⇒ 페이지 테이블의 인덱스 값
    - `p`에 해당하는 페이지 테이블 내용 ⇒ 프레임 번호 `f`
    - `p`는 `f`로 바뀌며 변위 `d`는 변하지 않음