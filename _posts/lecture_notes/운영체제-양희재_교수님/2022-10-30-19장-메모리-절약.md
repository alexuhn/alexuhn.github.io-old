---
title: "[운영체제-양희재 교수님]19강 메모리 절약"
excerpt: "동적 적재, 동적 연결, 그리고 swapping에 대하여"
categories:
  - lecture_notes
tags:
  - 운영체제-양희재 교수님
---

[경성대학교 양희재 교수님의 운영체제 19강](http://www.kocw.net/home/cview.do?lid=c75ca3cb3ea002f6)

# 메모리 낭비 방지 기술

## 동적 적재(Dynamic Loading)

- 적재(Load): 실행 파일을 메인 메모리에 올리는 것
    - OS를 올리는 경우를 부팅이라 한다.
- 동적 적재: 프로그램 실행에 반드시 필요한 루틴과 데이터만 적재
    - 모든 루틴(routine)이 다 사용되는 것은 아니다.
        - 예) 오류 처리용 루틴은 실제 오류가 발생할 때 올린다.
    - 모든 데이터(data)가 다 사용되는 것은 아니다.
        - 예) 배열을 전부 올려놓지 않는다.
    - 자바의 경우 모든 클래스가 다 사용되는 것은 아니다.
    - 따라서 실행 시 필요하면 그때 해당 부분을 메모리에 올린다.
- 정적 적재(Static loading)
    - 현대 운영체제는 대부분 동적 적재, 과거의 운영체제는 정적 적재

## 동적 연결(Dynamic Linking)

- 공통으로 사용하는 라이브러리 루틴(library routine)을 메모리에 중복으로 올리는 것은 낭비
    - 따라서 오직 하나의 라이브러리 루틴만 메모리에 적재
    - 해당 라이브러리를 사용하는 다른 애플리케이션 실행 시 이 루틴과 연결(link)
- 라이브러리 루틴 연결을 실행할 때까지 미룬다.
    - 원래 링크는 컴파일 이후 실행 파일을 만들기 전에 실행 ⇒ 정적 연결(Static linking)
    - 이는 낭비이므로 라이브러리를 실제로 사용할 때 링크 ⇒ 동적 연결(Dynamic Linking)
- 공통으로 사용하는 라이브러리
    - Linux에서는 공유 라이브러리(Shared Library)라 한다.
        - `.so`(shared object)
    - Windows에서는 동적 연결 라이브러리(Dynamic Linking Library)라 한다.
        - `.dll`

## Swapping

- 메모리에 적재되어 있으나 현재 사용되지 않고 있는 프로세스 이미지 존재
    - 실행 파일이 메인 메모리에 올라가면 code는 같아도 stack도 생기고 여러 변화가 생김 ⇒ 프로세스 이미지
    - 메인 메모리에 올라간 프로그램 ≠ 디스크에 있는 실행 파일
- 따라서 메모리 활용도 높이기 위해 이러한 프로세스 이미지를 Backing store(=swap device)로 몰아냄
    - Backing store
        - 일반적으로 메인 메모리 크기보다 큰 프로세스가 올 수 없으니 메인 메모리와 크기가 비슷하다.
        - 효율을 위해 이를 위한 디스크가 따로 존재할 수도 있다.
- Relocation register 사용으로 적재 위치는 무관
    - 기존에 있던 번지수에 가지 못하더라도 Relocation register가 이를 조정
- 프로세스 크기가 크면 backing store 입출력에 따른 부담 증가