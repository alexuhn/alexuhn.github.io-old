---
title: "[운영체제-양희재 교수님]2강 운영체제 역사"
excerpt: "운영체제의 역사와 OS 기술 천이에 대하여"
categories:
  - lecture_notes
tags:
  - 운영체제-양희재 교수님
---

[경성대학교 양희재 교수님의 운영체제 2강](http://www.kocw.net/home/cview.do?lid=97e80bf1d7a0098f)

# 역사

## No OS

- 컴퓨터는 1940년대 말 발명
- 초기 컴퓨터
    - 입력 장치(OCR) → 처리기(processer) & 메모리 → 프린터(line printer)
    - 작동 방식
        1. 프로그래머가 종이에 프로그램을 짜서 전산실에 넘긴다. 
        2. 프로그램을 카드에 구멍을 뚫어서 표현한 뒤 메모리에 적재
        3. 그다음 소스코드를 기계어로 바꿀 컴파일러를 메모리에 올린다.
        4. 컴파일러가 기계어로 번역한 결과를 실행하고 결과를 프린터에 찍는다.
    - 당시에는 OS가 없었다.

## Batch processing system

- operator가 하던 컴파일, 링크, 로드 작업을 전부 컴퓨터가 수행할 수 있도록 시스템을 만들자 ⇒ resident monitor ⇒ 최초의 OS
    - Batch ⇒ 컴파일하고, 하면 링크하고, 하면 로드하고 이런 식으로 꾸러미를 일괄적으로 작업한다는 의미

## Multiprogramming system

- 1960년대
- 하드웨어(메모리, 하드디스크) 기술이 발전하며 OS도 발전

### 배경

- 메모리에는 크게 OS와 한 개의 user program(컴파일러, 링크 등)이 놓인다.
- user program은 처음 CPU를 사용(계산 작업)
- 이후 IO도 사용하며, 이때는 CPU는 동작 안 함
- 이 작업이 계속 반복
- IO 작업을 마치기 전까지는 CPU가 할 일이 없어짐 ⇒ CPU idle
    - 당시에 매우 비싼 장비인 컴퓨터가 놀고 있다 ⇒ 낭비가 큼
    - 심지어 IO는 CPU에 비해 작업 속도가 느리다.
- 이를 해결해야 한다.

### 해결

- 메모리에 여러 프로그램을 돌리자.
- user program이 IO 작업을 하면 CPU는 다른 프로그램을 작업한다.
- CPU가 놀지 않고 계속 일할 수 있다.
    - idle time 대폭 감소, CPU 사용률 대폭 상승
- 메인 메모리에 이렇게 여러 프로그램을 올리는 OS를 다중 프로그래밍 시스템이라 한다.

### 고려해야 할 점

- CPU 스케줄링
    - 메인 메모리에 프로그램이 여러 개 있는데 무엇부터 먼저 실행헤야 할까?
    - 어떤 순서대로 실행해야 더 좋은 성능을 낼 수 있을까?
- 메모리 관리
    - 메모리에 user program을 어떤 식으로 배치해야 할까?
    - 종료된 프로그램으로 인해 비어있는 메모리가 생기면 이 공간에 다른 프로그램을 넣어야 할까?
- 보호
    - user program 1의 작업을 하던 중 user program 2의 메모리 공간을 침범하면 안 된다.

## Time-sharing system(TSS)

- 1960년대 후반, 1970년대 초반
    - 70년대 나온 대표적인 TSS ⇒ Unix
        - 현재는 Linux
    - 현재 대부분의 운영체제 또한 TSS
- 모니터와 키보드 등장
    - 컴퓨터와 interaction 가능(interactive, 대화형 컴퓨터)

### 문제

- 컴퓨터는 매우 고가의 장치였기에 하나의 컴퓨터에 여러 개의 단말(모니터와 키보드)을 붙여 사용
- CPU가 user 1의 작업을 하는 중 다른 단말은 아무 작업을 하지 못함
- 어떻게 동시에 여러 단말에서 작업이 가능할까?

### 해결

- 매우 짧은 시간 동안에만 user 1의 작업을 한 뒤, user 2의 작업으로 넘어가고 이를 계속 반복
    - 1/100초, 1/1000초와 같은 매우 짧은 시간 동안 작업
    - 만약 1/100초 동안 CPU가 작업한다면 3개의 단말이 존재할 경우 각 단말은 1초에 약 33번의 CPU 할당을 받을 수 있다.
    - 따라서 컴퓨터를 혼자 사용하고 있는 것처럼 느껴진다.
- 여러 작업을 동시에 하는 것처럼 보인다.

### 특징

- 일정 시간이 지나면 강제 전환하며 대화형 시스템을 가능케 함
- 단말 간 데이터를 주고받을 수 있게 됨 ⇒ 프로세스 간 통신 가능
- 여러 작업이 동시에 있는 상황이니 어떤 작업이 앞서냐, 뒤에 있냐에 대한 고민 필요 ⇒ 동기화
- 메모리 공간은 한정되어 있는데 단말이 무수히 존재 ⇒ 하드디스크의 일부를 메인 메모리인 것처럼 사용하는 기술 도입(가상메모리)

# OS 기술 천이

## 컴퓨터 구분

- 1970, 80년대의 컴퓨터 구분
    1. Supercomputer
    2. Mainframe
        1. 한 컴퓨터당 수백 대의 단말 사용
    3. Mini
        1. 한 컴퓨터당 수십 개의 단말 사용
    4. Micro
- 현대의 컴퓨터 구분
    - 현대에는 Network에 PC, Workstation, Server가 연결된 형태
    
    1. Supercomputer
    2. Server
    3. Workstation
    4. PC
    5. Handheld
        1. 노트북, 태블릿, 스마트폰
    6. Embedded

## 모든 컴퓨터에는 OS가 들어있다.

- 처음에는 규모가 작은 컴퓨터에 Batch processing system밖에 없었지만 이제는 TSS가 들어있다.
- 처음에는 규모가 큰 컴퓨터에만 있던 TSS OS가 이제는 Handheld에도 들어있다.
- TSS 이후에도 고등 컴퓨터 구조(Advanced Computer Architectures) 등장